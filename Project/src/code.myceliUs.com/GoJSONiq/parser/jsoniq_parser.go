// Code generated from jsoniq.g4 by ANTLR 4.7.1. DO NOT EDIT.

package parser // jsoniq

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 143, 833,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 150, 10, 2,
	5, 2, 152, 10, 2, 3, 2, 5, 2, 155, 10, 2, 3, 2, 3, 2, 5, 2, 159, 10, 2,
	3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 177, 10, 5, 3, 5, 3, 5, 7, 5, 181, 10, 5,
	12, 5, 14, 5, 184, 11, 5, 3, 5, 3, 5, 5, 5, 188, 10, 5, 3, 5, 3, 5, 7,
	5, 192, 10, 5, 12, 5, 14, 5, 195, 11, 5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 7, 3, 7, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9,
	3, 9, 3, 9, 5, 9, 216, 10, 9, 3, 9, 3, 9, 3, 9, 5, 9, 221, 10, 9, 3, 9,
	3, 9, 3, 9, 3, 9, 7, 9, 227, 10, 9, 12, 9, 14, 9, 230, 11, 9, 3, 10, 3,
	10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 239, 10, 11, 3, 11, 3, 11,
	3, 11, 3, 11, 3, 11, 7, 11, 246, 10, 11, 12, 11, 14, 11, 249, 11, 11, 5,
	11, 251, 10, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 258, 10, 12,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 265, 10, 12, 5, 12, 267, 10,
	12, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 273, 10, 13, 3, 13, 3, 13, 3, 13,
	5, 13, 278, 10, 13, 3, 13, 3, 13, 3, 13, 5, 13, 283, 10, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 5, 13, 290, 10, 13, 3, 14, 3, 14, 3, 14, 3, 14,
	5, 14, 296, 10, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 303, 10,
	14, 7, 14, 305, 10, 14, 12, 14, 14, 14, 308, 11, 14, 3, 15, 3, 15, 3, 15,
	7, 15, 313, 10, 15, 12, 15, 14, 15, 316, 11, 15, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 5, 16, 325, 10, 16, 3, 17, 3, 17, 5, 17, 329,
	10, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 337, 10, 17, 12,
	17, 14, 17, 340, 11, 17, 3, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 18,
	5, 18, 349, 10, 18, 3, 18, 3, 18, 5, 18, 353, 10, 18, 3, 18, 3, 18, 5,
	18, 357, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 365,
	10, 18, 3, 18, 3, 18, 5, 18, 369, 10, 18, 3, 18, 3, 18, 5, 18, 373, 10,
	18, 3, 18, 3, 18, 3, 18, 7, 18, 378, 10, 18, 12, 18, 14, 18, 381, 11, 18,
	3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 387, 10, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 3, 19, 3, 19, 5, 19, 395, 10, 19, 3, 19, 3, 19, 3, 19, 7, 19, 400,
	10, 19, 12, 19, 14, 19, 403, 11, 19, 3, 20, 3, 20, 3, 20, 3, 21, 3, 21,
	3, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 416, 10, 22, 3, 22, 3,
	22, 5, 22, 420, 10, 22, 3, 22, 3, 22, 5, 22, 424, 10, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 5, 22, 430, 10, 22, 3, 22, 3, 22, 5, 22, 434, 10, 22, 3,
	22, 3, 22, 5, 22, 438, 10, 22, 7, 22, 440, 10, 22, 12, 22, 14, 22, 443,
	11, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 450, 10, 23, 3, 23, 3,
	23, 5, 23, 454, 10, 23, 3, 23, 3, 23, 5, 23, 458, 10, 23, 3, 23, 3, 23,
	5, 23, 462, 10, 23, 3, 23, 3, 23, 3, 23, 5, 23, 467, 10, 23, 3, 23, 3,
	23, 5, 23, 471, 10, 23, 3, 23, 3, 23, 5, 23, 475, 10, 23, 7, 23, 477, 10,
	23, 12, 23, 14, 23, 480, 11, 23, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 486,
	10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 494, 10, 24, 3,
	24, 3, 24, 3, 24, 7, 24, 499, 10, 24, 12, 24, 14, 24, 502, 11, 24, 3, 24,
	3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 6, 25, 512, 10, 25, 13,
	25, 14, 25, 513, 3, 25, 3, 25, 3, 25, 3, 25, 3, 26, 3, 26, 6, 26, 522,
	10, 26, 13, 26, 14, 26, 523, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 6, 27, 534, 10, 27, 13, 27, 14, 27, 535, 3, 27, 3, 27, 5,
	27, 540, 10, 27, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28,
	549, 10, 28, 3, 28, 3, 28, 3, 28, 7, 28, 554, 10, 28, 12, 28, 14, 28, 557,
	11, 28, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	3, 29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 7, 31, 584, 10, 31, 12, 31, 14,
	31, 587, 11, 31, 3, 32, 3, 32, 3, 32, 7, 32, 592, 10, 32, 12, 32, 14, 32,
	595, 11, 32, 3, 33, 5, 33, 598, 10, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3,
	34, 5, 34, 605, 10, 34, 3, 35, 3, 35, 3, 35, 5, 35, 610, 10, 35, 3, 36,
	3, 36, 3, 36, 7, 36, 615, 10, 36, 12, 36, 14, 36, 618, 11, 36, 3, 37, 3,
	37, 3, 37, 5, 37, 623, 10, 37, 3, 38, 3, 38, 3, 38, 7, 38, 628, 10, 38,
	12, 38, 14, 38, 631, 11, 38, 3, 39, 3, 39, 3, 39, 7, 39, 636, 10, 39, 12,
	39, 14, 39, 639, 11, 39, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 645, 10, 40,
	3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 651, 10, 41, 3, 42, 3, 42, 3, 42, 3,
	42, 3, 42, 5, 42, 658, 10, 42, 5, 42, 660, 10, 42, 3, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 5, 43, 667, 10, 43, 5, 43, 669, 10, 43, 3, 44, 7, 44, 672,
	10, 44, 12, 44, 14, 44, 675, 11, 44, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45,
	7, 45, 682, 10, 45, 12, 45, 14, 45, 685, 11, 45, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 7, 46, 692, 10, 46, 12, 46, 14, 46, 695, 11, 46, 3, 47, 3, 47,
	3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 707, 10,
	48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 50, 3, 50, 3, 50, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 727, 10,
	51, 3, 52, 3, 52, 3, 52, 5, 52, 732, 10, 52, 3, 52, 3, 52, 3, 53, 3, 53,
	5, 53, 738, 10, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3,
	55, 3, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 5, 57, 756,
	10, 57, 3, 57, 3, 57, 3, 57, 3, 58, 7, 58, 762, 10, 58, 12, 58, 14, 58,
	765, 11, 58, 3, 59, 3, 59, 5, 59, 769, 10, 59, 3, 60, 3, 60, 3, 60, 3,
	60, 7, 60, 775, 10, 60, 12, 60, 14, 60, 778, 11, 60, 5, 60, 780, 10, 60,
	3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 5, 60, 787, 10, 60, 3, 61, 3, 61, 5,
	61, 791, 10, 61, 3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 5, 62, 798, 10, 62,
	3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 5, 63, 806, 10, 63, 5, 63, 808,
	10, 63, 3, 64, 3, 64, 3, 64, 5, 64, 813, 10, 64, 3, 65, 3, 65, 3, 66, 3,
	66, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 825, 10, 68, 3, 69,
	3, 69, 3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 2, 2, 72, 2, 4, 6, 8, 10, 12,
	14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
	50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
	86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
	118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 2, 17, 3, 2,
	41, 42, 3, 2, 48, 49, 3, 2, 51, 60, 3, 2, 78, 79, 3, 2, 80, 81, 4, 2, 4,
	4, 15, 19, 3, 2, 94, 99, 3, 2, 21, 22, 4, 2, 14, 14, 100, 102, 4, 2, 5,
	5, 23, 23, 5, 2, 14, 14, 21, 21, 23, 23, 3, 2, 108, 110, 3, 2, 111, 136,
	3, 2, 137, 139, 3, 2, 31, 32, 2, 887, 2, 154, 3, 2, 2, 2, 4, 160, 3, 2,
	2, 2, 6, 163, 3, 2, 2, 2, 8, 182, 3, 2, 2, 2, 10, 196, 3, 2, 2, 2, 12,
	201, 3, 2, 2, 2, 14, 205, 3, 2, 2, 2, 16, 211, 3, 2, 2, 2, 18, 231, 3,
	2, 2, 2, 20, 233, 3, 2, 2, 2, 22, 252, 3, 2, 2, 2, 24, 268, 3, 2, 2, 2,
	26, 291, 3, 2, 2, 2, 28, 309, 3, 2, 2, 2, 30, 324, 3, 2, 2, 2, 32, 328,
	3, 2, 2, 2, 34, 344, 3, 2, 2, 2, 36, 382, 3, 2, 2, 2, 38, 404, 3, 2, 2,
	2, 40, 407, 3, 2, 2, 2, 42, 410, 3, 2, 2, 2, 44, 449, 3, 2, 2, 2, 46, 481,
	3, 2, 2, 2, 48, 506, 3, 2, 2, 2, 50, 521, 3, 2, 2, 2, 52, 528, 3, 2, 2,
	2, 54, 544, 3, 2, 2, 2, 56, 561, 3, 2, 2, 2, 58, 570, 3, 2, 2, 2, 60, 580,
	3, 2, 2, 2, 62, 588, 3, 2, 2, 2, 64, 597, 3, 2, 2, 2, 66, 601, 3, 2, 2,
	2, 68, 606, 3, 2, 2, 2, 70, 611, 3, 2, 2, 2, 72, 619, 3, 2, 2, 2, 74, 624,
	3, 2, 2, 2, 76, 632, 3, 2, 2, 2, 78, 640, 3, 2, 2, 2, 80, 646, 3, 2, 2,
	2, 82, 652, 3, 2, 2, 2, 84, 661, 3, 2, 2, 2, 86, 673, 3, 2, 2, 2, 88, 678,
	3, 2, 2, 2, 90, 686, 3, 2, 2, 2, 92, 696, 3, 2, 2, 2, 94, 700, 3, 2, 2,
	2, 96, 708, 3, 2, 2, 2, 98, 714, 3, 2, 2, 2, 100, 726, 3, 2, 2, 2, 102,
	728, 3, 2, 2, 2, 104, 735, 3, 2, 2, 2, 106, 741, 3, 2, 2, 2, 108, 743,
	3, 2, 2, 2, 110, 748, 3, 2, 2, 2, 112, 755, 3, 2, 2, 2, 114, 763, 3, 2,
	2, 2, 116, 768, 3, 2, 2, 2, 118, 786, 3, 2, 2, 2, 120, 790, 3, 2, 2, 2,
	122, 795, 3, 2, 2, 2, 124, 807, 3, 2, 2, 2, 126, 812, 3, 2, 2, 2, 128,
	814, 3, 2, 2, 2, 130, 816, 3, 2, 2, 2, 132, 818, 3, 2, 2, 2, 134, 824,
	3, 2, 2, 2, 136, 826, 3, 2, 2, 2, 138, 828, 3, 2, 2, 2, 140, 830, 3, 2,
	2, 2, 142, 151, 7, 34, 2, 2, 143, 144, 7, 35, 2, 2, 144, 152, 7, 140, 2,
	2, 145, 146, 7, 36, 2, 2, 146, 149, 7, 140, 2, 2, 147, 148, 7, 35, 2, 2,
	148, 150, 7, 140, 2, 2, 149, 147, 3, 2, 2, 2, 149, 150, 3, 2, 2, 2, 150,
	152, 3, 2, 2, 2, 151, 143, 3, 2, 2, 2, 151, 145, 3, 2, 2, 2, 152, 153,
	3, 2, 2, 2, 153, 155, 7, 3, 2, 2, 154, 142, 3, 2, 2, 2, 154, 155, 3, 2,
	2, 2, 155, 158, 3, 2, 2, 2, 156, 159, 5, 6, 4, 2, 157, 159, 5, 4, 3, 2,
	158, 156, 3, 2, 2, 2, 158, 157, 3, 2, 2, 2, 159, 3, 3, 2, 2, 2, 160, 161,
	5, 8, 5, 2, 161, 162, 5, 28, 15, 2, 162, 5, 3, 2, 2, 2, 163, 164, 7, 37,
	2, 2, 164, 165, 7, 38, 2, 2, 165, 166, 7, 142, 2, 2, 166, 167, 7, 4, 2,
	2, 167, 168, 5, 132, 67, 2, 168, 169, 7, 3, 2, 2, 169, 170, 5, 8, 5, 2,
	170, 7, 3, 2, 2, 2, 171, 177, 5, 10, 6, 2, 172, 177, 5, 12, 7, 2, 173,
	177, 5, 14, 8, 2, 174, 177, 5, 16, 9, 2, 175, 177, 5, 20, 11, 2, 176, 171,
	3, 2, 2, 2, 176, 172, 3, 2, 2, 2, 176, 173, 3, 2, 2, 2, 176, 174, 3, 2,
	2, 2, 176, 175, 3, 2, 2, 2, 177, 178, 3, 2, 2, 2, 178, 179, 7, 3, 2, 2,
	179, 181, 3, 2, 2, 2, 180, 176, 3, 2, 2, 2, 181, 184, 3, 2, 2, 2, 182,
	180, 3, 2, 2, 2, 182, 183, 3, 2, 2, 2, 183, 193, 3, 2, 2, 2, 184, 182,
	3, 2, 2, 2, 185, 188, 5, 24, 13, 2, 186, 188, 5, 22, 12, 2, 187, 185, 3,
	2, 2, 2, 187, 186, 3, 2, 2, 2, 188, 189, 3, 2, 2, 2, 189, 190, 7, 3, 2,
	2, 190, 192, 3, 2, 2, 2, 191, 187, 3, 2, 2, 2, 192, 195, 3, 2, 2, 2, 193,
	191, 3, 2, 2, 2, 193, 194, 3, 2, 2, 2, 194, 9, 3, 2, 2, 2, 195, 193, 3,
	2, 2, 2, 196, 197, 7, 39, 2, 2, 197, 198, 7, 44, 2, 2, 198, 199, 7, 43,
	2, 2, 199, 200, 5, 132, 67, 2, 200, 11, 3, 2, 2, 2, 201, 202, 7, 39, 2,
	2, 202, 203, 7, 40, 2, 2, 203, 204, 9, 2, 2, 2, 204, 13, 3, 2, 2, 2, 205,
	206, 7, 39, 2, 2, 206, 207, 7, 44, 2, 2, 207, 208, 7, 45, 2, 2, 208, 209,
	7, 47, 2, 2, 209, 210, 9, 3, 2, 2, 210, 15, 3, 2, 2, 2, 211, 220, 7, 39,
	2, 2, 212, 215, 7, 50, 2, 2, 213, 214, 7, 142, 2, 2, 214, 216, 7, 5, 2,
	2, 215, 213, 3, 2, 2, 2, 215, 216, 3, 2, 2, 2, 216, 217, 3, 2, 2, 2, 217,
	221, 7, 142, 2, 2, 218, 219, 7, 44, 2, 2, 219, 221, 7, 50, 2, 2, 220, 212,
	3, 2, 2, 2, 220, 218, 3, 2, 2, 2, 221, 228, 3, 2, 2, 2, 222, 223, 5, 18,
	10, 2, 223, 224, 7, 4, 2, 2, 224, 225, 7, 140, 2, 2, 225, 227, 3, 2, 2,
	2, 226, 222, 3, 2, 2, 2, 227, 230, 3, 2, 2, 2, 228, 226, 3, 2, 2, 2, 228,
	229, 3, 2, 2, 2, 229, 17, 3, 2, 2, 2, 230, 228, 3, 2, 2, 2, 231, 232, 9,
	4, 2, 2, 232, 19, 3, 2, 2, 2, 233, 234, 7, 61, 2, 2, 234, 238, 7, 37, 2,
	2, 235, 236, 7, 38, 2, 2, 236, 237, 7, 142, 2, 2, 237, 239, 7, 4, 2, 2,
	238, 235, 3, 2, 2, 2, 238, 239, 3, 2, 2, 2, 239, 240, 3, 2, 2, 2, 240,
	250, 5, 132, 67, 2, 241, 242, 7, 62, 2, 2, 242, 247, 5, 132, 67, 2, 243,
	244, 7, 6, 2, 2, 244, 246, 5, 132, 67, 2, 245, 243, 3, 2, 2, 2, 246, 249,
	3, 2, 2, 2, 247, 245, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2, 248, 251, 3, 2,
	2, 2, 249, 247, 3, 2, 2, 2, 250, 241, 3, 2, 2, 2, 250, 251, 3, 2, 2, 2,
	251, 21, 3, 2, 2, 2, 252, 253, 7, 39, 2, 2, 253, 254, 7, 63, 2, 2, 254,
	257, 5, 102, 52, 2, 255, 256, 7, 66, 2, 2, 256, 258, 5, 124, 63, 2, 257,
	255, 3, 2, 2, 2, 257, 258, 3, 2, 2, 2, 258, 266, 3, 2, 2, 2, 259, 260,
	7, 7, 2, 2, 260, 267, 5, 30, 16, 2, 261, 264, 7, 64, 2, 2, 262, 263, 7,
	7, 2, 2, 263, 265, 5, 30, 16, 2, 264, 262, 3, 2, 2, 2, 264, 265, 3, 2,
	2, 2, 265, 267, 3, 2, 2, 2, 266, 259, 3, 2, 2, 2, 266, 261, 3, 2, 2, 2,
	267, 23, 3, 2, 2, 2, 268, 269, 7, 39, 2, 2, 269, 272, 7, 65, 2, 2, 270,
	271, 7, 142, 2, 2, 271, 273, 7, 5, 2, 2, 272, 270, 3, 2, 2, 2, 272, 273,
	3, 2, 2, 2, 273, 274, 3, 2, 2, 2, 274, 275, 7, 142, 2, 2, 275, 277, 7,
	8, 2, 2, 276, 278, 5, 26, 14, 2, 277, 276, 3, 2, 2, 2, 277, 278, 3, 2,
	2, 2, 278, 279, 3, 2, 2, 2, 279, 282, 7, 9, 2, 2, 280, 281, 7, 66, 2, 2,
	281, 283, 5, 124, 63, 2, 282, 280, 3, 2, 2, 2, 282, 283, 3, 2, 2, 2, 283,
	289, 3, 2, 2, 2, 284, 285, 7, 10, 2, 2, 285, 286, 5, 28, 15, 2, 286, 287,
	7, 11, 2, 2, 287, 290, 3, 2, 2, 2, 288, 290, 7, 64, 2, 2, 289, 284, 3,
	2, 2, 2, 289, 288, 3, 2, 2, 2, 290, 25, 3, 2, 2, 2, 291, 292, 7, 12, 2,
	2, 292, 295, 7, 142, 2, 2, 293, 294, 7, 66, 2, 2, 294, 296, 5, 124, 63,
	2, 295, 293, 3, 2, 2, 2, 295, 296, 3, 2, 2, 2, 296, 306, 3, 2, 2, 2, 297,
	298, 7, 6, 2, 2, 298, 299, 7, 12, 2, 2, 299, 302, 7, 142, 2, 2, 300, 301,
	7, 66, 2, 2, 301, 303, 5, 124, 63, 2, 302, 300, 3, 2, 2, 2, 302, 303, 3,
	2, 2, 2, 303, 305, 3, 2, 2, 2, 304, 297, 3, 2, 2, 2, 305, 308, 3, 2, 2,
	2, 306, 304, 3, 2, 2, 2, 306, 307, 3, 2, 2, 2, 307, 27, 3, 2, 2, 2, 308,
	306, 3, 2, 2, 2, 309, 314, 5, 30, 16, 2, 310, 311, 7, 6, 2, 2, 311, 313,
	5, 30, 16, 2, 312, 310, 3, 2, 2, 2, 313, 316, 3, 2, 2, 2, 314, 312, 3,
	2, 2, 2, 314, 315, 3, 2, 2, 2, 315, 29, 3, 2, 2, 2, 316, 314, 3, 2, 2,
	2, 317, 325, 5, 32, 17, 2, 318, 325, 5, 46, 24, 2, 319, 325, 5, 48, 25,
	2, 320, 325, 5, 52, 27, 2, 321, 325, 5, 56, 29, 2, 322, 325, 5, 58, 30,
	2, 323, 325, 5, 60, 31, 2, 324, 317, 3, 2, 2, 2, 324, 318, 3, 2, 2, 2,
	324, 319, 3, 2, 2, 2, 324, 320, 3, 2, 2, 2, 324, 321, 3, 2, 2, 2, 324,
	322, 3, 2, 2, 2, 324, 323, 3, 2, 2, 2, 325, 31, 3, 2, 2, 2, 326, 329, 5,
	34, 18, 2, 327, 329, 5, 36, 19, 2, 328, 326, 3, 2, 2, 2, 328, 327, 3, 2,
	2, 2, 329, 338, 3, 2, 2, 2, 330, 337, 5, 34, 18, 2, 331, 337, 5, 36, 19,
	2, 332, 337, 5, 40, 21, 2, 333, 337, 5, 42, 22, 2, 334, 337, 5, 44, 23,
	2, 335, 337, 5, 38, 20, 2, 336, 330, 3, 2, 2, 2, 336, 331, 3, 2, 2, 2,
	336, 332, 3, 2, 2, 2, 336, 333, 3, 2, 2, 2, 336, 334, 3, 2, 2, 2, 336,
	335, 3, 2, 2, 2, 337, 340, 3, 2, 2, 2, 338, 336, 3, 2, 2, 2, 338, 339,
	3, 2, 2, 2, 339, 341, 3, 2, 2, 2, 340, 338, 3, 2, 2, 2, 341, 342, 7, 67,
	2, 2, 342, 343, 5, 30, 16, 2, 343, 33, 3, 2, 2, 2, 344, 345, 7, 68, 2,
	2, 345, 348, 5, 102, 52, 2, 346, 347, 7, 66, 2, 2, 347, 349, 5, 124, 63,
	2, 348, 346, 3, 2, 2, 2, 348, 349, 3, 2, 2, 2, 349, 352, 3, 2, 2, 2, 350,
	351, 7, 70, 2, 2, 351, 353, 7, 47, 2, 2, 352, 350, 3, 2, 2, 2, 352, 353,
	3, 2, 2, 2, 353, 356, 3, 2, 2, 2, 354, 355, 7, 62, 2, 2, 355, 357, 5, 102,
	52, 2, 356, 354, 3, 2, 2, 2, 356, 357, 3, 2, 2, 2, 357, 358, 3, 2, 2, 2,
	358, 359, 7, 71, 2, 2, 359, 379, 5, 30, 16, 2, 360, 361, 7, 6, 2, 2, 361,
	364, 5, 102, 52, 2, 362, 363, 7, 66, 2, 2, 363, 365, 5, 124, 63, 2, 364,
	362, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 368, 3, 2, 2, 2, 366, 367,
	7, 70, 2, 2, 367, 369, 7, 47, 2, 2, 368, 366, 3, 2, 2, 2, 368, 369, 3,
	2, 2, 2, 369, 372, 3, 2, 2, 2, 370, 371, 7, 62, 2, 2, 371, 373, 5, 102,
	52, 2, 372, 370, 3, 2, 2, 2, 372, 373, 3, 2, 2, 2, 373, 374, 3, 2, 2, 2,
	374, 375, 7, 71, 2, 2, 375, 376, 5, 30, 16, 2, 376, 378, 3, 2, 2, 2, 377,
	360, 3, 2, 2, 2, 378, 381, 3, 2, 2, 2, 379, 377, 3, 2, 2, 2, 379, 380,
	3, 2, 2, 2, 380, 35, 3, 2, 2, 2, 381, 379, 3, 2, 2, 2, 382, 383, 7, 69,
	2, 2, 383, 386, 5, 102, 52, 2, 384, 385, 7, 66, 2, 2, 385, 387, 5, 124,
	63, 2, 386, 384, 3, 2, 2, 2, 386, 387, 3, 2, 2, 2, 387, 388, 3, 2, 2, 2,
	388, 389, 7, 7, 2, 2, 389, 401, 5, 30, 16, 2, 390, 391, 7, 6, 2, 2, 391,
	394, 5, 102, 52, 2, 392, 393, 7, 66, 2, 2, 393, 395, 5, 124, 63, 2, 394,
	392, 3, 2, 2, 2, 394, 395, 3, 2, 2, 2, 395, 396, 3, 2, 2, 2, 396, 397,
	7, 7, 2, 2, 397, 398, 5, 30, 16, 2, 398, 400, 3, 2, 2, 2, 399, 390, 3,
	2, 2, 2, 400, 403, 3, 2, 2, 2, 401, 399, 3, 2, 2, 2, 401, 402, 3, 2, 2,
	2, 402, 37, 3, 2, 2, 2, 403, 401, 3, 2, 2, 2, 404, 405, 7, 74, 2, 2, 405,
	406, 5, 102, 52, 2, 406, 39, 3, 2, 2, 2, 407, 408, 7, 75, 2, 2, 408, 409,
	5, 30, 16, 2, 409, 41, 3, 2, 2, 2, 410, 411, 7, 76, 2, 2, 411, 412, 7,
	77, 2, 2, 412, 419, 5, 102, 52, 2, 413, 414, 7, 66, 2, 2, 414, 416, 5,
	124, 63, 2, 415, 413, 3, 2, 2, 2, 415, 416, 3, 2, 2, 2, 416, 417, 3, 2,
	2, 2, 417, 418, 7, 7, 2, 2, 418, 420, 5, 30, 16, 2, 419, 415, 3, 2, 2,
	2, 419, 420, 3, 2, 2, 2, 420, 423, 3, 2, 2, 2, 421, 422, 7, 43, 2, 2, 422,
	424, 5, 132, 67, 2, 423, 421, 3, 2, 2, 2, 423, 424, 3, 2, 2, 2, 424, 441,
	3, 2, 2, 2, 425, 426, 7, 6, 2, 2, 426, 433, 5, 102, 52, 2, 427, 428, 7,
	66, 2, 2, 428, 430, 5, 124, 63, 2, 429, 427, 3, 2, 2, 2, 429, 430, 3, 2,
	2, 2, 430, 431, 3, 2, 2, 2, 431, 432, 7, 7, 2, 2, 432, 434, 5, 30, 16,
	2, 433, 429, 3, 2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 437, 3, 2, 2, 2, 435,
	436, 7, 43, 2, 2, 436, 438, 5, 132, 67, 2, 437, 435, 3, 2, 2, 2, 437, 438,
	3, 2, 2, 2, 438, 440, 3, 2, 2, 2, 439, 425, 3, 2, 2, 2, 440, 443, 3, 2,
	2, 2, 441, 439, 3, 2, 2, 2, 441, 442, 3, 2, 2, 2, 442, 43, 3, 2, 2, 2,
	443, 441, 3, 2, 2, 2, 444, 445, 7, 45, 2, 2, 445, 450, 7, 77, 2, 2, 446,
	447, 7, 46, 2, 2, 447, 448, 7, 45, 2, 2, 448, 450, 7, 77, 2, 2, 449, 444,
	3, 2, 2, 2, 449, 446, 3, 2, 2, 2, 450, 451, 3, 2, 2, 2, 451, 453, 5, 30,
	16, 2, 452, 454, 9, 5, 2, 2, 453, 452, 3, 2, 2, 2, 453, 454, 3, 2, 2, 2,
	454, 457, 3, 2, 2, 2, 455, 456, 7, 47, 2, 2, 456, 458, 9, 3, 2, 2, 457,
	455, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 461, 3, 2, 2, 2, 459, 460,
	7, 43, 2, 2, 460, 462, 5, 132, 67, 2, 461, 459, 3, 2, 2, 2, 461, 462, 3,
	2, 2, 2, 462, 478, 3, 2, 2, 2, 463, 464, 7, 6, 2, 2, 464, 466, 5, 30, 16,
	2, 465, 467, 9, 5, 2, 2, 466, 465, 3, 2, 2, 2, 466, 467, 3, 2, 2, 2, 467,
	470, 3, 2, 2, 2, 468, 469, 7, 47, 2, 2, 469, 471, 9, 3, 2, 2, 470, 468,
	3, 2, 2, 2, 470, 471, 3, 2, 2, 2, 471, 474, 3, 2, 2, 2, 472, 473, 7, 43,
	2, 2, 473, 475, 5, 132, 67, 2, 474, 472, 3, 2, 2, 2, 474, 475, 3, 2, 2,
	2, 475, 477, 3, 2, 2, 2, 476, 463, 3, 2, 2, 2, 477, 480, 3, 2, 2, 2, 478,
	476, 3, 2, 2, 2, 478, 479, 3, 2, 2, 2, 479, 45, 3, 2, 2, 2, 480, 478, 3,
	2, 2, 2, 481, 482, 9, 6, 2, 2, 482, 485, 5, 102, 52, 2, 483, 484, 7, 66,
	2, 2, 484, 486, 5, 124, 63, 2, 485, 483, 3, 2, 2, 2, 485, 486, 3, 2, 2,
	2, 486, 487, 3, 2, 2, 2, 487, 488, 7, 71, 2, 2, 488, 500, 5, 30, 16, 2,
	489, 490, 7, 6, 2, 2, 490, 493, 5, 102, 52, 2, 491, 492, 7, 66, 2, 2, 492,
	494, 5, 124, 63, 2, 493, 491, 3, 2, 2, 2, 493, 494, 3, 2, 2, 2, 494, 495,
	3, 2, 2, 2, 495, 496, 7, 71, 2, 2, 496, 497, 5, 30, 16, 2, 497, 499, 3,
	2, 2, 2, 498, 489, 3, 2, 2, 2, 499, 502, 3, 2, 2, 2, 500, 498, 3, 2, 2,
	2, 500, 501, 3, 2, 2, 2, 501, 503, 3, 2, 2, 2, 502, 500, 3, 2, 2, 2, 503,
	504, 7, 82, 2, 2, 504, 505, 5, 30, 16, 2, 505, 47, 3, 2, 2, 2, 506, 507,
	7, 83, 2, 2, 507, 508, 7, 8, 2, 2, 508, 509, 5, 28, 15, 2, 509, 511, 7,
	9, 2, 2, 510, 512, 5, 50, 26, 2, 511, 510, 3, 2, 2, 2, 512, 513, 3, 2,
	2, 2, 513, 511, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 515, 3, 2, 2, 2,
	515, 516, 7, 44, 2, 2, 516, 517, 7, 67, 2, 2, 517, 518, 5, 30, 16, 2, 518,
	49, 3, 2, 2, 2, 519, 520, 7, 84, 2, 2, 520, 522, 5, 30, 16, 2, 521, 519,
	3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523, 521, 3, 2, 2, 2, 523, 524, 3, 2,
	2, 2, 524, 525, 3, 2, 2, 2, 525, 526, 7, 67, 2, 2, 526, 527, 5, 30, 16,
	2, 527, 51, 3, 2, 2, 2, 528, 529, 7, 85, 2, 2, 529, 530, 7, 8, 2, 2, 530,
	531, 5, 28, 15, 2, 531, 533, 7, 9, 2, 2, 532, 534, 5, 54, 28, 2, 533, 532,
	3, 2, 2, 2, 534, 535, 3, 2, 2, 2, 535, 533, 3, 2, 2, 2, 535, 536, 3, 2,
	2, 2, 536, 537, 3, 2, 2, 2, 537, 539, 7, 44, 2, 2, 538, 540, 5, 102, 52,
	2, 539, 538, 3, 2, 2, 2, 539, 540, 3, 2, 2, 2, 540, 541, 3, 2, 2, 2, 541,
	542, 7, 67, 2, 2, 542, 543, 5, 30, 16, 2, 543, 53, 3, 2, 2, 2, 544, 548,
	7, 84, 2, 2, 545, 546, 5, 102, 52, 2, 546, 547, 7, 66, 2, 2, 547, 549,
	3, 2, 2, 2, 548, 545, 3, 2, 2, 2, 548, 549, 3, 2, 2, 2, 549, 550, 3, 2,
	2, 2, 550, 555, 5, 124, 63, 2, 551, 552, 7, 13, 2, 2, 552, 554, 5, 124,
	63, 2, 553, 551, 3, 2, 2, 2, 554, 557, 3, 2, 2, 2, 555, 553, 3, 2, 2, 2,
	555, 556, 3, 2, 2, 2, 556, 558, 3, 2, 2, 2, 557, 555, 3, 2, 2, 2, 558,
	559, 7, 67, 2, 2, 559, 560, 5, 30, 16, 2, 560, 55, 3, 2, 2, 2, 561, 562,
	7, 86, 2, 2, 562, 563, 7, 8, 2, 2, 563, 564, 5, 28, 15, 2, 564, 565, 7,
	9, 2, 2, 565, 566, 7, 87, 2, 2, 566, 567, 5, 30, 16, 2, 567, 568, 7, 88,
	2, 2, 568, 569, 5, 30, 16, 2, 569, 57, 3, 2, 2, 2, 570, 571, 7, 89, 2,
	2, 571, 572, 7, 10, 2, 2, 572, 573, 5, 28, 15, 2, 573, 574, 7, 11, 2, 2,
	574, 575, 7, 90, 2, 2, 575, 576, 7, 14, 2, 2, 576, 577, 7, 10, 2, 2, 577,
	578, 5, 28, 15, 2, 578, 579, 7, 11, 2, 2, 579, 59, 3, 2, 2, 2, 580, 585,
	5, 62, 32, 2, 581, 582, 7, 92, 2, 2, 582, 584, 5, 62, 32, 2, 583, 581,
	3, 2, 2, 2, 584, 587, 3, 2, 2, 2, 585, 583, 3, 2, 2, 2, 585, 586, 3, 2,
	2, 2, 586, 61, 3, 2, 2, 2, 587, 585, 3, 2, 2, 2, 588, 593, 5, 64, 33, 2,
	589, 590, 7, 91, 2, 2, 590, 592, 5, 64, 33, 2, 591, 589, 3, 2, 2, 2, 592,
	595, 3, 2, 2, 2, 593, 591, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 63, 3,
	2, 2, 2, 595, 593, 3, 2, 2, 2, 596, 598, 7, 93, 2, 2, 597, 596, 3, 2, 2,
	2, 597, 598, 3, 2, 2, 2, 598, 599, 3, 2, 2, 2, 599, 600, 5, 66, 34, 2,
	600, 65, 3, 2, 2, 2, 601, 604, 5, 68, 35, 2, 602, 603, 9, 7, 2, 2, 603,
	605, 5, 68, 35, 2, 604, 602, 3, 2, 2, 2, 604, 605, 3, 2, 2, 2, 605, 67,
	3, 2, 2, 2, 606, 609, 5, 70, 36, 2, 607, 608, 9, 8, 2, 2, 608, 610, 5,
	70, 36, 2, 609, 607, 3, 2, 2, 2, 609, 610, 3, 2, 2, 2, 610, 69, 3, 2, 2,
	2, 611, 616, 5, 72, 37, 2, 612, 613, 7, 20, 2, 2, 613, 615, 5, 72, 37,
	2, 614, 612, 3, 2, 2, 2, 615, 618, 3, 2, 2, 2, 616, 614, 3, 2, 2, 2, 616,
	617, 3, 2, 2, 2, 617, 71, 3, 2, 2, 2, 618, 616, 3, 2, 2, 2, 619, 622, 5,
	74, 38, 2, 620, 621, 7, 73, 2, 2, 621, 623, 5, 74, 38, 2, 622, 620, 3,
	2, 2, 2, 622, 623, 3, 2, 2, 2, 623, 73, 3, 2, 2, 2, 624, 629, 5, 76, 39,
	2, 625, 626, 9, 9, 2, 2, 626, 628, 5, 76, 39, 2, 627, 625, 3, 2, 2, 2,
	628, 631, 3, 2, 2, 2, 629, 627, 3, 2, 2, 2, 629, 630, 3, 2, 2, 2, 630,
	75, 3, 2, 2, 2, 631, 629, 3, 2, 2, 2, 632, 637, 5, 78, 40, 2, 633, 634,
	9, 10, 2, 2, 634, 636, 5, 78, 40, 2, 635, 633, 3, 2, 2, 2, 636, 639, 3,
	2, 2, 2, 637, 635, 3, 2, 2, 2, 637, 638, 3, 2, 2, 2, 638, 77, 3, 2, 2,
	2, 639, 637, 3, 2, 2, 2, 640, 644, 5, 80, 41, 2, 641, 642, 7, 103, 2, 2,
	642, 643, 7, 72, 2, 2, 643, 645, 5, 124, 63, 2, 644, 641, 3, 2, 2, 2, 644,
	645, 3, 2, 2, 2, 645, 79, 3, 2, 2, 2, 646, 650, 5, 82, 42, 2, 647, 648,
	7, 104, 2, 2, 648, 649, 7, 66, 2, 2, 649, 651, 5, 124, 63, 2, 650, 647,
	3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 81, 3, 2, 2, 2, 652, 659, 5, 84,
	43, 2, 653, 654, 7, 105, 2, 2, 654, 655, 7, 66, 2, 2, 655, 657, 5, 130,
	66, 2, 656, 658, 7, 23, 2, 2, 657, 656, 3, 2, 2, 2, 657, 658, 3, 2, 2,
	2, 658, 660, 3, 2, 2, 2, 659, 653, 3, 2, 2, 2, 659, 660, 3, 2, 2, 2, 660,
	83, 3, 2, 2, 2, 661, 668, 5, 86, 44, 2, 662, 663, 7, 106, 2, 2, 663, 664,
	7, 66, 2, 2, 664, 666, 5, 130, 66, 2, 665, 667, 7, 23, 2, 2, 666, 665,
	3, 2, 2, 2, 666, 667, 3, 2, 2, 2, 667, 669, 3, 2, 2, 2, 668, 662, 3, 2,
	2, 2, 668, 669, 3, 2, 2, 2, 669, 85, 3, 2, 2, 2, 670, 672, 9, 9, 2, 2,
	671, 670, 3, 2, 2, 2, 672, 675, 3, 2, 2, 2, 673, 671, 3, 2, 2, 2, 673,
	674, 3, 2, 2, 2, 674, 676, 3, 2, 2, 2, 675, 673, 3, 2, 2, 2, 676, 677,
	5, 88, 45, 2, 677, 87, 3, 2, 2, 2, 678, 683, 5, 90, 46, 2, 679, 680, 7,
	24, 2, 2, 680, 682, 5, 90, 46, 2, 681, 679, 3, 2, 2, 2, 682, 685, 3, 2,
	2, 2, 683, 681, 3, 2, 2, 2, 683, 684, 3, 2, 2, 2, 684, 89, 3, 2, 2, 2,
	685, 683, 3, 2, 2, 2, 686, 693, 5, 100, 51, 2, 687, 692, 5, 92, 47, 2,
	688, 692, 5, 94, 48, 2, 689, 692, 5, 96, 49, 2, 690, 692, 5, 98, 50, 2,
	691, 687, 3, 2, 2, 2, 691, 688, 3, 2, 2, 2, 691, 689, 3, 2, 2, 2, 691,
	690, 3, 2, 2, 2, 692, 695, 3, 2, 2, 2, 693, 691, 3, 2, 2, 2, 693, 694,
	3, 2, 2, 2, 694, 91, 3, 2, 2, 2, 695, 693, 3, 2, 2, 2, 696, 697, 7, 25,
	2, 2, 697, 698, 5, 28, 15, 2, 698, 699, 7, 26, 2, 2, 699, 93, 3, 2, 2,
	2, 700, 706, 7, 27, 2, 2, 701, 707, 7, 140, 2, 2, 702, 707, 7, 142, 2,
	2, 703, 707, 5, 104, 53, 2, 704, 707, 5, 102, 52, 2, 705, 707, 5, 106,
	54, 2, 706, 701, 3, 2, 2, 2, 706, 702, 3, 2, 2, 2, 706, 703, 3, 2, 2, 2,
	706, 704, 3, 2, 2, 2, 706, 705, 3, 2, 2, 2, 707, 95, 3, 2, 2, 2, 708, 709,
	7, 25, 2, 2, 709, 710, 7, 25, 2, 2, 710, 711, 5, 28, 15, 2, 711, 712, 7,
	26, 2, 2, 712, 713, 7, 26, 2, 2, 713, 97, 3, 2, 2, 2, 714, 715, 7, 25,
	2, 2, 715, 716, 7, 26, 2, 2, 716, 99, 3, 2, 2, 2, 717, 727, 5, 134, 68,
	2, 718, 727, 5, 102, 52, 2, 719, 727, 5, 104, 53, 2, 720, 727, 5, 106,
	54, 2, 721, 727, 5, 112, 57, 2, 722, 727, 5, 108, 55, 2, 723, 727, 5, 110,
	56, 2, 724, 727, 5, 118, 60, 2, 725, 727, 5, 122, 62, 2, 726, 717, 3, 2,
	2, 2, 726, 718, 3, 2, 2, 2, 726, 719, 3, 2, 2, 2, 726, 720, 3, 2, 2, 2,
	726, 721, 3, 2, 2, 2, 726, 722, 3, 2, 2, 2, 726, 723, 3, 2, 2, 2, 726,
	724, 3, 2, 2, 2, 726, 725, 3, 2, 2, 2, 727, 101, 3, 2, 2, 2, 728, 731,
	7, 12, 2, 2, 729, 730, 7, 142, 2, 2, 730, 732, 7, 5, 2, 2, 731, 729, 3,
	2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 733, 3, 2, 2, 2, 733, 734, 7, 142,
	2, 2, 734, 103, 3, 2, 2, 2, 735, 737, 7, 8, 2, 2, 736, 738, 5, 28, 15,
	2, 737, 736, 3, 2, 2, 2, 737, 738, 3, 2, 2, 2, 738, 739, 3, 2, 2, 2, 739,
	740, 7, 9, 2, 2, 740, 105, 3, 2, 2, 2, 741, 742, 7, 28, 2, 2, 742, 107,
	3, 2, 2, 2, 743, 744, 7, 41, 2, 2, 744, 745, 7, 10, 2, 2, 745, 746, 5,
	28, 15, 2, 746, 747, 7, 11, 2, 2, 747, 109, 3, 2, 2, 2, 748, 749, 7, 42,
	2, 2, 749, 750, 7, 10, 2, 2, 750, 751, 5, 28, 15, 2, 751, 752, 7, 11, 2,
	2, 752, 111, 3, 2, 2, 2, 753, 754, 7, 142, 2, 2, 754, 756, 7, 5, 2, 2,
	755, 753, 3, 2, 2, 2, 755, 756, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 757,
	758, 7, 142, 2, 2, 758, 759, 5, 114, 58, 2, 759, 113, 3, 2, 2, 2, 760,
	762, 5, 116, 59, 2, 761, 760, 3, 2, 2, 2, 762, 765, 3, 2, 2, 2, 763, 761,
	3, 2, 2, 2, 763, 764, 3, 2, 2, 2, 764, 115, 3, 2, 2, 2, 765, 763, 3, 2,
	2, 2, 766, 769, 5, 30, 16, 2, 767, 769, 7, 23, 2, 2, 768, 766, 3, 2, 2,
	2, 768, 767, 3, 2, 2, 2, 769, 117, 3, 2, 2, 2, 770, 779, 7, 10, 2, 2, 771,
	776, 5, 120, 61, 2, 772, 773, 7, 6, 2, 2, 773, 775, 5, 120, 61, 2, 774,
	772, 3, 2, 2, 2, 775, 778, 3, 2, 2, 2, 776, 774, 3, 2, 2, 2, 776, 777,
	3, 2, 2, 2, 777, 780, 3, 2, 2, 2, 778, 776, 3, 2, 2, 2, 779, 771, 3, 2,
	2, 2, 779, 780, 3, 2, 2, 2, 780, 781, 3, 2, 2, 2, 781, 787, 7, 11, 2, 2,
	782, 783, 7, 29, 2, 2, 783, 784, 5, 28, 15, 2, 784, 785, 7, 30, 2, 2, 785,
	787, 3, 2, 2, 2, 786, 770, 3, 2, 2, 2, 786, 782, 3, 2, 2, 2, 787, 119,
	3, 2, 2, 2, 788, 791, 5, 30, 16, 2, 789, 791, 7, 142, 2, 2, 790, 788, 3,
	2, 2, 2, 790, 789, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 793, 9, 11, 2,
	2, 793, 794, 5, 30, 16, 2, 794, 121, 3, 2, 2, 2, 795, 797, 7, 25, 2, 2,
	796, 798, 5, 28, 15, 2, 797, 796, 3, 2, 2, 2, 797, 798, 3, 2, 2, 2, 798,
	799, 3, 2, 2, 2, 799, 800, 7, 26, 2, 2, 800, 123, 3, 2, 2, 2, 801, 802,
	7, 8, 2, 2, 802, 808, 7, 9, 2, 2, 803, 805, 5, 126, 64, 2, 804, 806, 9,
	12, 2, 2, 805, 804, 3, 2, 2, 2, 805, 806, 3, 2, 2, 2, 806, 808, 3, 2, 2,
	2, 807, 801, 3, 2, 2, 2, 807, 803, 3, 2, 2, 2, 808, 125, 3, 2, 2, 2, 809,
	813, 7, 107, 2, 2, 810, 813, 5, 128, 65, 2, 811, 813, 5, 130, 66, 2, 812,
	809, 3, 2, 2, 2, 812, 810, 3, 2, 2, 2, 812, 811, 3, 2, 2, 2, 813, 127,
	3, 2, 2, 2, 814, 815, 9, 13, 2, 2, 815, 129, 3, 2, 2, 2, 816, 817, 9, 14,
	2, 2, 817, 131, 3, 2, 2, 2, 818, 819, 7, 140, 2, 2, 819, 133, 3, 2, 2,
	2, 820, 825, 5, 136, 69, 2, 821, 825, 7, 140, 2, 2, 822, 825, 5, 138, 70,
	2, 823, 825, 5, 140, 71, 2, 824, 820, 3, 2, 2, 2, 824, 821, 3, 2, 2, 2,
	824, 822, 3, 2, 2, 2, 824, 823, 3, 2, 2, 2, 825, 135, 3, 2, 2, 2, 826,
	827, 9, 15, 2, 2, 827, 137, 3, 2, 2, 2, 828, 829, 9, 16, 2, 2, 829, 139,
	3, 2, 2, 2, 830, 831, 7, 33, 2, 2, 831, 141, 3, 2, 2, 2, 100, 149, 151,
	154, 158, 176, 182, 187, 193, 215, 220, 228, 238, 247, 250, 257, 264, 266,
	272, 277, 282, 289, 295, 302, 306, 314, 324, 328, 336, 338, 348, 352, 356,
	364, 368, 372, 379, 386, 394, 401, 415, 419, 423, 429, 433, 437, 441, 449,
	453, 457, 461, 466, 470, 474, 478, 485, 493, 500, 513, 523, 535, 539, 548,
	555, 585, 593, 597, 604, 609, 616, 622, 629, 637, 644, 650, 657, 659, 666,
	668, 673, 683, 691, 693, 706, 726, 731, 737, 755, 763, 768, 776, 779, 786,
	790, 797, 805, 807, 812, 824,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "';'", "'='", "':'", "','", "':='", "'('", "')'", "'{'", "'}'", "'$'",
	"'|'", "'*'", "'!='", "'<'", "'<='", "'>'", "'=>'", "'||'", "'+'", "'-'",
	"'?'", "'!'", "'['", "']'", "'.'", "'$$'", "'{|'", "'|}'", "'true'", "'false'",
	"'null'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "K_JSONIQ", "K_ENCODING",
	"K_VERSION", "K_MODULE", "K_NAMESPACE", "K_DECLARE", "K_ORDERING", "K_ORDERED",
	"K_UNORDERED", "K_COLLATION", "K_DEFAULT", "K_ORDER", "K_STABLE", "K_EMPTY",
	"K_GREATEST", "K_LEAST", "K_DECIMAL_FORMAT", "K_DECIMAL_SEPARATOR", "K_GROUPING_SEPARATOR",
	"K_INFINITY", "K_MINUS_SIGN", "K_NAN", "K_PERCENT", "K_PER_MILLE", "K_ZERO_DIGIT",
	"K_DIGIT", "K_PATTERN_SEPARATOR", "K_IMPORT", "K_AT", "K_VARIABLE", "K_EXTERNAL",
	"K_FUNCTION", "K_AS", "K_RETURN", "K_FOR", "K_LET", "K_ALLOWING", "K_IN",
	"K_OF", "K_TO", "K_COUNT", "K_WHERE", "K_GROUP", "K_BY", "K_ASCENDING",
	"K_DESCENDING", "K_SOME", "K_EVERY", "K_SATISFIES", "K_SWITCH", "K_CASE",
	"K_TYPESWITCH", "K_IF", "K_THEN", "K_ELSE", "K_TRY", "K_CATCH", "K_AND",
	"K_OR", "K_NOT", "K_EQ", "K_NE", "K_LT", "K_LE", "K_GT", "K_GE", "K_DIV",
	"K_IDIV", "K_MOD", "K_INSTANCE", "K_TREAT", "K_CASTABLE", "K_CAST", "K_ITEM",
	"K_OBJECT", "K_ARRAY", "K_JSON_ITEM", "K_ATOMIC", "K_STRING", "K_INTEGER",
	"K_DECIMAL", "K_DOUBLE", "K_BOOLEAN", "K_LONG", "K_SHORT", "K_BYTE", "K_FLOAT",
	"K_DATE", "K_DATETIME", "K_DATETIMESTAMP", "K_GDAY", "K_GMONTH", "K_GMONTHDAY",
	"K_GYEAR", "K_GYEARMONTH", "K_TIME", "K_DURATION", "K_DAYTIMEDURATION",
	"K_YEARMONTHDURATION", "K_BASE64NIBARY", "K_HEXBINARY", "K_ANYURI", "K_NULL",
	"IntegerLiteral", "DecimalLiteral", "DoubleLiteral", "StringLiteral", "Comment",
	"NCName", "WS",
}

var ruleNames = []string{
	"program", "mainModule", "libraryModule", "prolog", "defaultCollationDecl",
	"orderingModeDecl", "emptyOrderDecl", "decimalFormatDecl", "dfPropertyName",
	"moduleImport", "varDecl", "functionDecl", "paramList", "expr", "exprSingle",
	"flowrExpr", "forClause", "letClause", "countClause", "whereClause", "groupByClause",
	"orderByClause", "quantifiedExpr", "switchExpr", "switchCaseClause", "typeswitchExpr",
	"caseClause", "ifExpr", "tryCatchExpr", "orExpr", "andExpr", "notExpr",
	"comparisonExpr2", "comparisonExpr", "stringConcatExpr", "rangeExpr", "additiveExpr",
	"multiplicativeExpr", "instanceofExpr", "treatExpr", "castableExpr", "castExpr",
	"unaryExpr", "simpleMapExpr", "postfixExpr", "predicate", "objectLookup",
	"arrayLookup", "arrayUnboxing", "primaryExpr", "varRef", "parenthesizedExpr",
	"contextItemExpr", "orderedExpr", "unorderedExpr", "functionCall", "argumentList",
	"argument", "objectConstructor", "pairConstructor", "arrayConstructor",
	"sequenceType", "itemType", "jsonItemTest", "atomicType", "uriLiteral",
	"literal", "numericLiteral", "booleanLiteral", "nullLiteral",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type jsoniqParser struct {
	*antlr.BaseParser
}

func NewjsoniqParser(input antlr.TokenStream) *jsoniqParser {
	this := new(jsoniqParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "jsoniq.g4"

	return this
}

// jsoniqParser tokens.
const (
	jsoniqParserEOF                  = antlr.TokenEOF
	jsoniqParserT__0                 = 1
	jsoniqParserT__1                 = 2
	jsoniqParserT__2                 = 3
	jsoniqParserT__3                 = 4
	jsoniqParserT__4                 = 5
	jsoniqParserT__5                 = 6
	jsoniqParserT__6                 = 7
	jsoniqParserT__7                 = 8
	jsoniqParserT__8                 = 9
	jsoniqParserT__9                 = 10
	jsoniqParserT__10                = 11
	jsoniqParserT__11                = 12
	jsoniqParserT__12                = 13
	jsoniqParserT__13                = 14
	jsoniqParserT__14                = 15
	jsoniqParserT__15                = 16
	jsoniqParserT__16                = 17
	jsoniqParserT__17                = 18
	jsoniqParserT__18                = 19
	jsoniqParserT__19                = 20
	jsoniqParserT__20                = 21
	jsoniqParserT__21                = 22
	jsoniqParserT__22                = 23
	jsoniqParserT__23                = 24
	jsoniqParserT__24                = 25
	jsoniqParserT__25                = 26
	jsoniqParserT__26                = 27
	jsoniqParserT__27                = 28
	jsoniqParserT__28                = 29
	jsoniqParserT__29                = 30
	jsoniqParserT__30                = 31
	jsoniqParserK_JSONIQ             = 32
	jsoniqParserK_ENCODING           = 33
	jsoniqParserK_VERSION            = 34
	jsoniqParserK_MODULE             = 35
	jsoniqParserK_NAMESPACE          = 36
	jsoniqParserK_DECLARE            = 37
	jsoniqParserK_ORDERING           = 38
	jsoniqParserK_ORDERED            = 39
	jsoniqParserK_UNORDERED          = 40
	jsoniqParserK_COLLATION          = 41
	jsoniqParserK_DEFAULT            = 42
	jsoniqParserK_ORDER              = 43
	jsoniqParserK_STABLE             = 44
	jsoniqParserK_EMPTY              = 45
	jsoniqParserK_GREATEST           = 46
	jsoniqParserK_LEAST              = 47
	jsoniqParserK_DECIMAL_FORMAT     = 48
	jsoniqParserK_DECIMAL_SEPARATOR  = 49
	jsoniqParserK_GROUPING_SEPARATOR = 50
	jsoniqParserK_INFINITY           = 51
	jsoniqParserK_MINUS_SIGN         = 52
	jsoniqParserK_NAN                = 53
	jsoniqParserK_PERCENT            = 54
	jsoniqParserK_PER_MILLE          = 55
	jsoniqParserK_ZERO_DIGIT         = 56
	jsoniqParserK_DIGIT              = 57
	jsoniqParserK_PATTERN_SEPARATOR  = 58
	jsoniqParserK_IMPORT             = 59
	jsoniqParserK_AT                 = 60
	jsoniqParserK_VARIABLE           = 61
	jsoniqParserK_EXTERNAL           = 62
	jsoniqParserK_FUNCTION           = 63
	jsoniqParserK_AS                 = 64
	jsoniqParserK_RETURN             = 65
	jsoniqParserK_FOR                = 66
	jsoniqParserK_LET                = 67
	jsoniqParserK_ALLOWING           = 68
	jsoniqParserK_IN                 = 69
	jsoniqParserK_OF                 = 70
	jsoniqParserK_TO                 = 71
	jsoniqParserK_COUNT              = 72
	jsoniqParserK_WHERE              = 73
	jsoniqParserK_GROUP              = 74
	jsoniqParserK_BY                 = 75
	jsoniqParserK_ASCENDING          = 76
	jsoniqParserK_DESCENDING         = 77
	jsoniqParserK_SOME               = 78
	jsoniqParserK_EVERY              = 79
	jsoniqParserK_SATISFIES          = 80
	jsoniqParserK_SWITCH             = 81
	jsoniqParserK_CASE               = 82
	jsoniqParserK_TYPESWITCH         = 83
	jsoniqParserK_IF                 = 84
	jsoniqParserK_THEN               = 85
	jsoniqParserK_ELSE               = 86
	jsoniqParserK_TRY                = 87
	jsoniqParserK_CATCH              = 88
	jsoniqParserK_AND                = 89
	jsoniqParserK_OR                 = 90
	jsoniqParserK_NOT                = 91
	jsoniqParserK_EQ                 = 92
	jsoniqParserK_NE                 = 93
	jsoniqParserK_LT                 = 94
	jsoniqParserK_LE                 = 95
	jsoniqParserK_GT                 = 96
	jsoniqParserK_GE                 = 97
	jsoniqParserK_DIV                = 98
	jsoniqParserK_IDIV               = 99
	jsoniqParserK_MOD                = 100
	jsoniqParserK_INSTANCE           = 101
	jsoniqParserK_TREAT              = 102
	jsoniqParserK_CASTABLE           = 103
	jsoniqParserK_CAST               = 104
	jsoniqParserK_ITEM               = 105
	jsoniqParserK_OBJECT             = 106
	jsoniqParserK_ARRAY              = 107
	jsoniqParserK_JSON_ITEM          = 108
	jsoniqParserK_ATOMIC             = 109
	jsoniqParserK_STRING             = 110
	jsoniqParserK_INTEGER            = 111
	jsoniqParserK_DECIMAL            = 112
	jsoniqParserK_DOUBLE             = 113
	jsoniqParserK_BOOLEAN            = 114
	jsoniqParserK_LONG               = 115
	jsoniqParserK_SHORT              = 116
	jsoniqParserK_BYTE               = 117
	jsoniqParserK_FLOAT              = 118
	jsoniqParserK_DATE               = 119
	jsoniqParserK_DATETIME           = 120
	jsoniqParserK_DATETIMESTAMP      = 121
	jsoniqParserK_GDAY               = 122
	jsoniqParserK_GMONTH             = 123
	jsoniqParserK_GMONTHDAY          = 124
	jsoniqParserK_GYEAR              = 125
	jsoniqParserK_GYEARMONTH         = 126
	jsoniqParserK_TIME               = 127
	jsoniqParserK_DURATION           = 128
	jsoniqParserK_DAYTIMEDURATION    = 129
	jsoniqParserK_YEARMONTHDURATION  = 130
	jsoniqParserK_BASE64NIBARY       = 131
	jsoniqParserK_HEXBINARY          = 132
	jsoniqParserK_ANYURI             = 133
	jsoniqParserK_NULL               = 134
	jsoniqParserIntegerLiteral       = 135
	jsoniqParserDecimalLiteral       = 136
	jsoniqParserDoubleLiteral        = 137
	jsoniqParserStringLiteral        = 138
	jsoniqParserComment              = 139
	jsoniqParserNCName               = 140
	jsoniqParserWS                   = 141
)

// jsoniqParser rules.
const (
	jsoniqParserRULE_program              = 0
	jsoniqParserRULE_mainModule           = 1
	jsoniqParserRULE_libraryModule        = 2
	jsoniqParserRULE_prolog               = 3
	jsoniqParserRULE_defaultCollationDecl = 4
	jsoniqParserRULE_orderingModeDecl     = 5
	jsoniqParserRULE_emptyOrderDecl       = 6
	jsoniqParserRULE_decimalFormatDecl    = 7
	jsoniqParserRULE_dfPropertyName       = 8
	jsoniqParserRULE_moduleImport         = 9
	jsoniqParserRULE_varDecl              = 10
	jsoniqParserRULE_functionDecl         = 11
	jsoniqParserRULE_paramList            = 12
	jsoniqParserRULE_expr                 = 13
	jsoniqParserRULE_exprSingle           = 14
	jsoniqParserRULE_flowrExpr            = 15
	jsoniqParserRULE_forClause            = 16
	jsoniqParserRULE_letClause            = 17
	jsoniqParserRULE_countClause          = 18
	jsoniqParserRULE_whereClause          = 19
	jsoniqParserRULE_groupByClause        = 20
	jsoniqParserRULE_orderByClause        = 21
	jsoniqParserRULE_quantifiedExpr       = 22
	jsoniqParserRULE_switchExpr           = 23
	jsoniqParserRULE_switchCaseClause     = 24
	jsoniqParserRULE_typeswitchExpr       = 25
	jsoniqParserRULE_caseClause           = 26
	jsoniqParserRULE_ifExpr               = 27
	jsoniqParserRULE_tryCatchExpr         = 28
	jsoniqParserRULE_orExpr               = 29
	jsoniqParserRULE_andExpr              = 30
	jsoniqParserRULE_notExpr              = 31
	jsoniqParserRULE_comparisonExpr2      = 32
	jsoniqParserRULE_comparisonExpr       = 33
	jsoniqParserRULE_stringConcatExpr     = 34
	jsoniqParserRULE_rangeExpr            = 35
	jsoniqParserRULE_additiveExpr         = 36
	jsoniqParserRULE_multiplicativeExpr   = 37
	jsoniqParserRULE_instanceofExpr       = 38
	jsoniqParserRULE_treatExpr            = 39
	jsoniqParserRULE_castableExpr         = 40
	jsoniqParserRULE_castExpr             = 41
	jsoniqParserRULE_unaryExpr            = 42
	jsoniqParserRULE_simpleMapExpr        = 43
	jsoniqParserRULE_postfixExpr          = 44
	jsoniqParserRULE_predicate            = 45
	jsoniqParserRULE_objectLookup         = 46
	jsoniqParserRULE_arrayLookup          = 47
	jsoniqParserRULE_arrayUnboxing        = 48
	jsoniqParserRULE_primaryExpr          = 49
	jsoniqParserRULE_varRef               = 50
	jsoniqParserRULE_parenthesizedExpr    = 51
	jsoniqParserRULE_contextItemExpr      = 52
	jsoniqParserRULE_orderedExpr          = 53
	jsoniqParserRULE_unorderedExpr        = 54
	jsoniqParserRULE_functionCall         = 55
	jsoniqParserRULE_argumentList         = 56
	jsoniqParserRULE_argument             = 57
	jsoniqParserRULE_objectConstructor    = 58
	jsoniqParserRULE_pairConstructor      = 59
	jsoniqParserRULE_arrayConstructor     = 60
	jsoniqParserRULE_sequenceType         = 61
	jsoniqParserRULE_itemType             = 62
	jsoniqParserRULE_jsonItemTest         = 63
	jsoniqParserRULE_atomicType           = 64
	jsoniqParserRULE_uriLiteral           = 65
	jsoniqParserRULE_literal              = 66
	jsoniqParserRULE_numericLiteral       = 67
	jsoniqParserRULE_booleanLiteral       = 68
	jsoniqParserRULE_nullLiteral          = 69
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_program
	return p
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) LibraryModule() ILibraryModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryModuleContext)
}

func (s *ProgramContext) MainModule() IMainModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMainModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMainModuleContext)
}

func (s *ProgramContext) K_JSONIQ() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_JSONIQ, 0)
}

func (s *ProgramContext) K_ENCODING() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ENCODING, 0)
}

func (s *ProgramContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserStringLiteral)
}

func (s *ProgramContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserStringLiteral, i)
}

func (s *ProgramContext) K_VERSION() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_VERSION, 0)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *jsoniqParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, jsoniqParserRULE_program)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(152)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_JSONIQ {
		{
			p.SetState(140)
			p.Match(jsoniqParserK_JSONIQ)
		}
		p.SetState(149)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case jsoniqParserK_ENCODING:
			{
				p.SetState(141)
				p.Match(jsoniqParserK_ENCODING)
			}
			{
				p.SetState(142)
				p.Match(jsoniqParserStringLiteral)
			}

		case jsoniqParserK_VERSION:
			{
				p.SetState(143)
				p.Match(jsoniqParserK_VERSION)
			}
			{
				p.SetState(144)
				p.Match(jsoniqParserStringLiteral)
			}
			p.SetState(147)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == jsoniqParserK_ENCODING {
				{
					p.SetState(145)
					p.Match(jsoniqParserK_ENCODING)
				}
				{
					p.SetState(146)
					p.Match(jsoniqParserStringLiteral)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(151)
			p.Match(jsoniqParserT__0)
		}

	}
	p.SetState(156)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserK_MODULE:
		{
			p.SetState(154)
			p.LibraryModule()
		}

	case jsoniqParserT__5, jsoniqParserT__7, jsoniqParserT__9, jsoniqParserT__18, jsoniqParserT__19, jsoniqParserT__22, jsoniqParserT__25, jsoniqParserT__26, jsoniqParserT__28, jsoniqParserT__29, jsoniqParserT__30, jsoniqParserK_DECLARE, jsoniqParserK_ORDERED, jsoniqParserK_UNORDERED, jsoniqParserK_IMPORT, jsoniqParserK_FOR, jsoniqParserK_LET, jsoniqParserK_SOME, jsoniqParserK_EVERY, jsoniqParserK_SWITCH, jsoniqParserK_TYPESWITCH, jsoniqParserK_IF, jsoniqParserK_TRY, jsoniqParserK_NOT, jsoniqParserIntegerLiteral, jsoniqParserDecimalLiteral, jsoniqParserDoubleLiteral, jsoniqParserStringLiteral, jsoniqParserNCName:
		{
			p.SetState(155)
			p.MainModule()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMainModuleContext is an interface to support dynamic dispatch.
type IMainModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMainModuleContext differentiates from other interfaces.
	IsMainModuleContext()
}

type MainModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMainModuleContext() *MainModuleContext {
	var p = new(MainModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_mainModule
	return p
}

func (*MainModuleContext) IsMainModuleContext() {}

func NewMainModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MainModuleContext {
	var p = new(MainModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_mainModule

	return p
}

func (s *MainModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *MainModuleContext) Prolog() IPrologContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrologContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrologContext)
}

func (s *MainModuleContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MainModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MainModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MainModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterMainModule(s)
	}
}

func (s *MainModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitMainModule(s)
	}
}

func (p *jsoniqParser) MainModule() (localctx IMainModuleContext) {
	localctx = NewMainModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, jsoniqParserRULE_mainModule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(158)
		p.Prolog()
	}
	{
		p.SetState(159)
		p.Expr()
	}

	return localctx
}

// ILibraryModuleContext is an interface to support dynamic dispatch.
type ILibraryModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryModuleContext differentiates from other interfaces.
	IsLibraryModuleContext()
}

type LibraryModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryModuleContext() *LibraryModuleContext {
	var p = new(LibraryModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_libraryModule
	return p
}

func (*LibraryModuleContext) IsLibraryModuleContext() {}

func NewLibraryModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryModuleContext {
	var p = new(LibraryModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_libraryModule

	return p
}

func (s *LibraryModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryModuleContext) K_MODULE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_MODULE, 0)
}

func (s *LibraryModuleContext) K_NAMESPACE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_NAMESPACE, 0)
}

func (s *LibraryModuleContext) NCName() antlr.TerminalNode {
	return s.GetToken(jsoniqParserNCName, 0)
}

func (s *LibraryModuleContext) UriLiteral() IUriLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUriLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUriLiteralContext)
}

func (s *LibraryModuleContext) Prolog() IPrologContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrologContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrologContext)
}

func (s *LibraryModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterLibraryModule(s)
	}
}

func (s *LibraryModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitLibraryModule(s)
	}
}

func (p *jsoniqParser) LibraryModule() (localctx ILibraryModuleContext) {
	localctx = NewLibraryModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, jsoniqParserRULE_libraryModule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(161)
		p.Match(jsoniqParserK_MODULE)
	}
	{
		p.SetState(162)
		p.Match(jsoniqParserK_NAMESPACE)
	}
	{
		p.SetState(163)
		p.Match(jsoniqParserNCName)
	}
	{
		p.SetState(164)
		p.Match(jsoniqParserT__1)
	}
	{
		p.SetState(165)
		p.UriLiteral()
	}
	{
		p.SetState(166)
		p.Match(jsoniqParserT__0)
	}
	{
		p.SetState(167)
		p.Prolog()
	}

	return localctx
}

// IPrologContext is an interface to support dynamic dispatch.
type IPrologContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrologContext differentiates from other interfaces.
	IsPrologContext()
}

type PrologContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrologContext() *PrologContext {
	var p = new(PrologContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_prolog
	return p
}

func (*PrologContext) IsPrologContext() {}

func NewPrologContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrologContext {
	var p = new(PrologContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_prolog

	return p
}

func (s *PrologContext) GetParser() antlr.Parser { return s.parser }

func (s *PrologContext) AllDefaultCollationDecl() []IDefaultCollationDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefaultCollationDeclContext)(nil)).Elem())
	var tst = make([]IDefaultCollationDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefaultCollationDeclContext)
		}
	}

	return tst
}

func (s *PrologContext) DefaultCollationDecl(i int) IDefaultCollationDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultCollationDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefaultCollationDeclContext)
}

func (s *PrologContext) AllOrderingModeDecl() []IOrderingModeDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderingModeDeclContext)(nil)).Elem())
	var tst = make([]IOrderingModeDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderingModeDeclContext)
		}
	}

	return tst
}

func (s *PrologContext) OrderingModeDecl(i int) IOrderingModeDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderingModeDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderingModeDeclContext)
}

func (s *PrologContext) AllEmptyOrderDecl() []IEmptyOrderDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEmptyOrderDeclContext)(nil)).Elem())
	var tst = make([]IEmptyOrderDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEmptyOrderDeclContext)
		}
	}

	return tst
}

func (s *PrologContext) EmptyOrderDecl(i int) IEmptyOrderDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmptyOrderDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEmptyOrderDeclContext)
}

func (s *PrologContext) AllDecimalFormatDecl() []IDecimalFormatDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecimalFormatDeclContext)(nil)).Elem())
	var tst = make([]IDecimalFormatDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecimalFormatDeclContext)
		}
	}

	return tst
}

func (s *PrologContext) DecimalFormatDecl(i int) IDecimalFormatDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalFormatDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecimalFormatDeclContext)
}

func (s *PrologContext) AllModuleImport() []IModuleImportContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleImportContext)(nil)).Elem())
	var tst = make([]IModuleImportContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleImportContext)
		}
	}

	return tst
}

func (s *PrologContext) ModuleImport(i int) IModuleImportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleImportContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleImportContext)
}

func (s *PrologContext) AllFunctionDecl() []IFunctionDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionDeclContext)(nil)).Elem())
	var tst = make([]IFunctionDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionDeclContext)
		}
	}

	return tst
}

func (s *PrologContext) FunctionDecl(i int) IFunctionDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclContext)
}

func (s *PrologContext) AllVarDecl() []IVarDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVarDeclContext)(nil)).Elem())
	var tst = make([]IVarDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVarDeclContext)
		}
	}

	return tst
}

func (s *PrologContext) VarDecl(i int) IVarDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVarDeclContext)
}

func (s *PrologContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrologContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrologContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterProlog(s)
	}
}

func (s *PrologContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitProlog(s)
	}
}

func (p *jsoniqParser) Prolog() (localctx IPrologContext) {
	localctx = NewPrologContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, jsoniqParserRULE_prolog)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(180)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(174)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(169)
					p.DefaultCollationDecl()
				}

			case 2:
				{
					p.SetState(170)
					p.OrderingModeDecl()
				}

			case 3:
				{
					p.SetState(171)
					p.EmptyOrderDecl()
				}

			case 4:
				{
					p.SetState(172)
					p.DecimalFormatDecl()
				}

			case 5:
				{
					p.SetState(173)
					p.ModuleImport()
				}

			}
			{
				p.SetState(176)
				p.Match(jsoniqParserT__0)
			}

		}
		p.SetState(182)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}
	p.SetState(191)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserK_DECLARE {
		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(183)
				p.FunctionDecl()
			}

		case 2:
			{
				p.SetState(184)
				p.VarDecl()
			}

		}
		{
			p.SetState(187)
			p.Match(jsoniqParserT__0)
		}

		p.SetState(193)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDefaultCollationDeclContext is an interface to support dynamic dispatch.
type IDefaultCollationDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultCollationDeclContext differentiates from other interfaces.
	IsDefaultCollationDeclContext()
}

type DefaultCollationDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultCollationDeclContext() *DefaultCollationDeclContext {
	var p = new(DefaultCollationDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_defaultCollationDecl
	return p
}

func (*DefaultCollationDeclContext) IsDefaultCollationDeclContext() {}

func NewDefaultCollationDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultCollationDeclContext {
	var p = new(DefaultCollationDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_defaultCollationDecl

	return p
}

func (s *DefaultCollationDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultCollationDeclContext) K_DECLARE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DECLARE, 0)
}

func (s *DefaultCollationDeclContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DEFAULT, 0)
}

func (s *DefaultCollationDeclContext) K_COLLATION() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_COLLATION, 0)
}

func (s *DefaultCollationDeclContext) UriLiteral() IUriLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUriLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUriLiteralContext)
}

func (s *DefaultCollationDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultCollationDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultCollationDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterDefaultCollationDecl(s)
	}
}

func (s *DefaultCollationDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitDefaultCollationDecl(s)
	}
}

func (p *jsoniqParser) DefaultCollationDecl() (localctx IDefaultCollationDeclContext) {
	localctx = NewDefaultCollationDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, jsoniqParserRULE_defaultCollationDecl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(194)
		p.Match(jsoniqParserK_DECLARE)
	}
	{
		p.SetState(195)
		p.Match(jsoniqParserK_DEFAULT)
	}
	{
		p.SetState(196)
		p.Match(jsoniqParserK_COLLATION)
	}
	{
		p.SetState(197)
		p.UriLiteral()
	}

	return localctx
}

// IOrderingModeDeclContext is an interface to support dynamic dispatch.
type IOrderingModeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderingModeDeclContext differentiates from other interfaces.
	IsOrderingModeDeclContext()
}

type OrderingModeDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderingModeDeclContext() *OrderingModeDeclContext {
	var p = new(OrderingModeDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_orderingModeDecl
	return p
}

func (*OrderingModeDeclContext) IsOrderingModeDeclContext() {}

func NewOrderingModeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderingModeDeclContext {
	var p = new(OrderingModeDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_orderingModeDecl

	return p
}

func (s *OrderingModeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderingModeDeclContext) K_DECLARE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DECLARE, 0)
}

func (s *OrderingModeDeclContext) K_ORDERING() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ORDERING, 0)
}

func (s *OrderingModeDeclContext) K_ORDERED() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ORDERED, 0)
}

func (s *OrderingModeDeclContext) K_UNORDERED() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_UNORDERED, 0)
}

func (s *OrderingModeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderingModeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderingModeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterOrderingModeDecl(s)
	}
}

func (s *OrderingModeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitOrderingModeDecl(s)
	}
}

func (p *jsoniqParser) OrderingModeDecl() (localctx IOrderingModeDeclContext) {
	localctx = NewOrderingModeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, jsoniqParserRULE_orderingModeDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(199)
		p.Match(jsoniqParserK_DECLARE)
	}
	{
		p.SetState(200)
		p.Match(jsoniqParserK_ORDERING)
	}
	{
		p.SetState(201)
		_la = p.GetTokenStream().LA(1)

		if !(_la == jsoniqParserK_ORDERED || _la == jsoniqParserK_UNORDERED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEmptyOrderDeclContext is an interface to support dynamic dispatch.
type IEmptyOrderDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyOrderDeclContext differentiates from other interfaces.
	IsEmptyOrderDeclContext()
}

type EmptyOrderDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyOrderDeclContext() *EmptyOrderDeclContext {
	var p = new(EmptyOrderDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_emptyOrderDecl
	return p
}

func (*EmptyOrderDeclContext) IsEmptyOrderDeclContext() {}

func NewEmptyOrderDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyOrderDeclContext {
	var p = new(EmptyOrderDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_emptyOrderDecl

	return p
}

func (s *EmptyOrderDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyOrderDeclContext) K_DECLARE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DECLARE, 0)
}

func (s *EmptyOrderDeclContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DEFAULT, 0)
}

func (s *EmptyOrderDeclContext) K_ORDER() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ORDER, 0)
}

func (s *EmptyOrderDeclContext) K_EMPTY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_EMPTY, 0)
}

func (s *EmptyOrderDeclContext) K_GREATEST() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GREATEST, 0)
}

func (s *EmptyOrderDeclContext) K_LEAST() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_LEAST, 0)
}

func (s *EmptyOrderDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyOrderDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyOrderDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterEmptyOrderDecl(s)
	}
}

func (s *EmptyOrderDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitEmptyOrderDecl(s)
	}
}

func (p *jsoniqParser) EmptyOrderDecl() (localctx IEmptyOrderDeclContext) {
	localctx = NewEmptyOrderDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, jsoniqParserRULE_emptyOrderDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(203)
		p.Match(jsoniqParserK_DECLARE)
	}
	{
		p.SetState(204)
		p.Match(jsoniqParserK_DEFAULT)
	}
	{
		p.SetState(205)
		p.Match(jsoniqParserK_ORDER)
	}
	{
		p.SetState(206)
		p.Match(jsoniqParserK_EMPTY)
	}
	{
		p.SetState(207)
		_la = p.GetTokenStream().LA(1)

		if !(_la == jsoniqParserK_GREATEST || _la == jsoniqParserK_LEAST) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDecimalFormatDeclContext is an interface to support dynamic dispatch.
type IDecimalFormatDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalFormatDeclContext differentiates from other interfaces.
	IsDecimalFormatDeclContext()
}

type DecimalFormatDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalFormatDeclContext() *DecimalFormatDeclContext {
	var p = new(DecimalFormatDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_decimalFormatDecl
	return p
}

func (*DecimalFormatDeclContext) IsDecimalFormatDeclContext() {}

func NewDecimalFormatDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalFormatDeclContext {
	var p = new(DecimalFormatDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_decimalFormatDecl

	return p
}

func (s *DecimalFormatDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalFormatDeclContext) K_DECLARE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DECLARE, 0)
}

func (s *DecimalFormatDeclContext) AllDfPropertyName() []IDfPropertyNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDfPropertyNameContext)(nil)).Elem())
	var tst = make([]IDfPropertyNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDfPropertyNameContext)
		}
	}

	return tst
}

func (s *DecimalFormatDeclContext) DfPropertyName(i int) IDfPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDfPropertyNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDfPropertyNameContext)
}

func (s *DecimalFormatDeclContext) AllStringLiteral() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserStringLiteral)
}

func (s *DecimalFormatDeclContext) StringLiteral(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserStringLiteral, i)
}

func (s *DecimalFormatDeclContext) K_DECIMAL_FORMAT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DECIMAL_FORMAT, 0)
}

func (s *DecimalFormatDeclContext) AllNCName() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserNCName)
}

func (s *DecimalFormatDeclContext) NCName(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserNCName, i)
}

func (s *DecimalFormatDeclContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DEFAULT, 0)
}

func (s *DecimalFormatDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalFormatDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalFormatDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterDecimalFormatDecl(s)
	}
}

func (s *DecimalFormatDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitDecimalFormatDecl(s)
	}
}

func (p *jsoniqParser) DecimalFormatDecl() (localctx IDecimalFormatDeclContext) {
	localctx = NewDecimalFormatDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, jsoniqParserRULE_decimalFormatDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(209)
		p.Match(jsoniqParserK_DECLARE)
	}
	p.SetState(218)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserK_DECIMAL_FORMAT:
		{
			p.SetState(210)
			p.Match(jsoniqParserK_DECIMAL_FORMAT)
		}
		p.SetState(213)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(211)
				p.Match(jsoniqParserNCName)
			}
			{
				p.SetState(212)
				p.Match(jsoniqParserT__2)
			}

		}
		{
			p.SetState(215)
			p.Match(jsoniqParserNCName)
		}

	case jsoniqParserK_DEFAULT:
		{
			p.SetState(216)
			p.Match(jsoniqParserK_DEFAULT)
		}
		{
			p.SetState(217)
			p.Match(jsoniqParserK_DECIMAL_FORMAT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-49)&-(0x1f+1)) == 0 && ((1<<uint((_la-49)))&((1<<(jsoniqParserK_DECIMAL_SEPARATOR-49))|(1<<(jsoniqParserK_GROUPING_SEPARATOR-49))|(1<<(jsoniqParserK_INFINITY-49))|(1<<(jsoniqParserK_MINUS_SIGN-49))|(1<<(jsoniqParserK_NAN-49))|(1<<(jsoniqParserK_PERCENT-49))|(1<<(jsoniqParserK_PER_MILLE-49))|(1<<(jsoniqParserK_ZERO_DIGIT-49))|(1<<(jsoniqParserK_DIGIT-49))|(1<<(jsoniqParserK_PATTERN_SEPARATOR-49)))) != 0 {
		{
			p.SetState(220)
			p.DfPropertyName()
		}
		{
			p.SetState(221)
			p.Match(jsoniqParserT__1)
		}
		{
			p.SetState(222)
			p.Match(jsoniqParserStringLiteral)
		}

		p.SetState(228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDfPropertyNameContext is an interface to support dynamic dispatch.
type IDfPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDfPropertyNameContext differentiates from other interfaces.
	IsDfPropertyNameContext()
}

type DfPropertyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDfPropertyNameContext() *DfPropertyNameContext {
	var p = new(DfPropertyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_dfPropertyName
	return p
}

func (*DfPropertyNameContext) IsDfPropertyNameContext() {}

func NewDfPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DfPropertyNameContext {
	var p = new(DfPropertyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_dfPropertyName

	return p
}

func (s *DfPropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DfPropertyNameContext) K_DECIMAL_SEPARATOR() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DECIMAL_SEPARATOR, 0)
}

func (s *DfPropertyNameContext) K_GROUPING_SEPARATOR() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GROUPING_SEPARATOR, 0)
}

func (s *DfPropertyNameContext) K_INFINITY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_INFINITY, 0)
}

func (s *DfPropertyNameContext) K_MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_MINUS_SIGN, 0)
}

func (s *DfPropertyNameContext) K_NAN() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_NAN, 0)
}

func (s *DfPropertyNameContext) K_PERCENT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_PERCENT, 0)
}

func (s *DfPropertyNameContext) K_PER_MILLE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_PER_MILLE, 0)
}

func (s *DfPropertyNameContext) K_ZERO_DIGIT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ZERO_DIGIT, 0)
}

func (s *DfPropertyNameContext) K_DIGIT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DIGIT, 0)
}

func (s *DfPropertyNameContext) K_PATTERN_SEPARATOR() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_PATTERN_SEPARATOR, 0)
}

func (s *DfPropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DfPropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DfPropertyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterDfPropertyName(s)
	}
}

func (s *DfPropertyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitDfPropertyName(s)
	}
}

func (p *jsoniqParser) DfPropertyName() (localctx IDfPropertyNameContext) {
	localctx = NewDfPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, jsoniqParserRULE_dfPropertyName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(229)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-49)&-(0x1f+1)) == 0 && ((1<<uint((_la-49)))&((1<<(jsoniqParserK_DECIMAL_SEPARATOR-49))|(1<<(jsoniqParserK_GROUPING_SEPARATOR-49))|(1<<(jsoniqParserK_INFINITY-49))|(1<<(jsoniqParserK_MINUS_SIGN-49))|(1<<(jsoniqParserK_NAN-49))|(1<<(jsoniqParserK_PERCENT-49))|(1<<(jsoniqParserK_PER_MILLE-49))|(1<<(jsoniqParserK_ZERO_DIGIT-49))|(1<<(jsoniqParserK_DIGIT-49))|(1<<(jsoniqParserK_PATTERN_SEPARATOR-49)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IModuleImportContext is an interface to support dynamic dispatch.
type IModuleImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleImportContext differentiates from other interfaces.
	IsModuleImportContext()
}

type ModuleImportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleImportContext() *ModuleImportContext {
	var p = new(ModuleImportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_moduleImport
	return p
}

func (*ModuleImportContext) IsModuleImportContext() {}

func NewModuleImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleImportContext {
	var p = new(ModuleImportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_moduleImport

	return p
}

func (s *ModuleImportContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleImportContext) K_IMPORT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_IMPORT, 0)
}

func (s *ModuleImportContext) K_MODULE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_MODULE, 0)
}

func (s *ModuleImportContext) AllUriLiteral() []IUriLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUriLiteralContext)(nil)).Elem())
	var tst = make([]IUriLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUriLiteralContext)
		}
	}

	return tst
}

func (s *ModuleImportContext) UriLiteral(i int) IUriLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUriLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUriLiteralContext)
}

func (s *ModuleImportContext) K_NAMESPACE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_NAMESPACE, 0)
}

func (s *ModuleImportContext) NCName() antlr.TerminalNode {
	return s.GetToken(jsoniqParserNCName, 0)
}

func (s *ModuleImportContext) K_AT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AT, 0)
}

func (s *ModuleImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterModuleImport(s)
	}
}

func (s *ModuleImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitModuleImport(s)
	}
}

func (p *jsoniqParser) ModuleImport() (localctx IModuleImportContext) {
	localctx = NewModuleImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, jsoniqParserRULE_moduleImport)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(231)
		p.Match(jsoniqParserK_IMPORT)
	}
	{
		p.SetState(232)
		p.Match(jsoniqParserK_MODULE)
	}
	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_NAMESPACE {
		{
			p.SetState(233)
			p.Match(jsoniqParserK_NAMESPACE)
		}
		{
			p.SetState(234)
			p.Match(jsoniqParserNCName)
		}
		{
			p.SetState(235)
			p.Match(jsoniqParserT__1)
		}

	}
	{
		p.SetState(238)
		p.UriLiteral()
	}
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_AT {
		{
			p.SetState(239)
			p.Match(jsoniqParserK_AT)
		}
		{
			p.SetState(240)
			p.UriLiteral()
		}
		p.SetState(245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == jsoniqParserT__3 {
			{
				p.SetState(241)
				p.Match(jsoniqParserT__3)
			}
			{
				p.SetState(242)
				p.UriLiteral()
			}

			p.SetState(247)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IVarDeclContext is an interface to support dynamic dispatch.
type IVarDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarDeclContext differentiates from other interfaces.
	IsVarDeclContext()
}

type VarDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarDeclContext() *VarDeclContext {
	var p = new(VarDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_varDecl
	return p
}

func (*VarDeclContext) IsVarDeclContext() {}

func NewVarDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarDeclContext {
	var p = new(VarDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_varDecl

	return p
}

func (s *VarDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *VarDeclContext) K_DECLARE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DECLARE, 0)
}

func (s *VarDeclContext) K_VARIABLE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_VARIABLE, 0)
}

func (s *VarDeclContext) VarRef() IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *VarDeclContext) K_AS() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, 0)
}

func (s *VarDeclContext) SequenceType() ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *VarDeclContext) ExprSingle() IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *VarDeclContext) K_EXTERNAL() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_EXTERNAL, 0)
}

func (s *VarDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterVarDecl(s)
	}
}

func (s *VarDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitVarDecl(s)
	}
}

func (p *jsoniqParser) VarDecl() (localctx IVarDeclContext) {
	localctx = NewVarDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, jsoniqParserRULE_varDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(250)
		p.Match(jsoniqParserK_DECLARE)
	}
	{
		p.SetState(251)
		p.Match(jsoniqParserK_VARIABLE)
	}
	{
		p.SetState(252)
		p.VarRef()
	}
	p.SetState(255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_AS {
		{
			p.SetState(253)
			p.Match(jsoniqParserK_AS)
		}
		{
			p.SetState(254)
			p.SequenceType()
		}

	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserT__4:
		{
			p.SetState(257)
			p.Match(jsoniqParserT__4)
		}
		{
			p.SetState(258)
			p.ExprSingle()
		}

	case jsoniqParserK_EXTERNAL:
		{
			p.SetState(259)
			p.Match(jsoniqParserK_EXTERNAL)
		}
		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserT__4 {
			{
				p.SetState(260)
				p.Match(jsoniqParserT__4)
			}
			{
				p.SetState(261)
				p.ExprSingle()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionDeclContext is an interface to support dynamic dispatch.
type IFunctionDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclContext differentiates from other interfaces.
	IsFunctionDeclContext()
}

type FunctionDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclContext() *FunctionDeclContext {
	var p = new(FunctionDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_functionDecl
	return p
}

func (*FunctionDeclContext) IsFunctionDeclContext() {}

func NewFunctionDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclContext {
	var p = new(FunctionDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_functionDecl

	return p
}

func (s *FunctionDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclContext) K_DECLARE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DECLARE, 0)
}

func (s *FunctionDeclContext) K_FUNCTION() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_FUNCTION, 0)
}

func (s *FunctionDeclContext) AllNCName() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserNCName)
}

func (s *FunctionDeclContext) NCName(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserNCName, i)
}

func (s *FunctionDeclContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *FunctionDeclContext) K_EXTERNAL() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_EXTERNAL, 0)
}

func (s *FunctionDeclContext) ParamList() IParamListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *FunctionDeclContext) K_AS() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, 0)
}

func (s *FunctionDeclContext) SequenceType() ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *FunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitFunctionDecl(s)
	}
}

func (p *jsoniqParser) FunctionDecl() (localctx IFunctionDeclContext) {
	localctx = NewFunctionDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, jsoniqParserRULE_functionDecl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(266)
		p.Match(jsoniqParserK_DECLARE)
	}
	{
		p.SetState(267)
		p.Match(jsoniqParserK_FUNCTION)
	}
	p.SetState(270)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(268)
			p.Match(jsoniqParserNCName)
		}
		{
			p.SetState(269)
			p.Match(jsoniqParserT__2)
		}

	}
	{
		p.SetState(272)
		p.Match(jsoniqParserNCName)
	}
	{
		p.SetState(273)
		p.Match(jsoniqParserT__5)
	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserT__9 {
		{
			p.SetState(274)
			p.ParamList()
		}

	}
	{
		p.SetState(277)
		p.Match(jsoniqParserT__6)
	}
	p.SetState(280)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_AS {
		{
			p.SetState(278)
			p.Match(jsoniqParserK_AS)
		}
		{
			p.SetState(279)
			p.SequenceType()
		}

	}
	p.SetState(287)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserT__7:
		{
			p.SetState(282)
			p.Match(jsoniqParserT__7)
		}
		{
			p.SetState(283)
			p.Expr()
		}
		{
			p.SetState(284)
			p.Match(jsoniqParserT__8)
		}

	case jsoniqParserK_EXTERNAL:
		{
			p.SetState(286)
			p.Match(jsoniqParserK_EXTERNAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParamListContext is an interface to support dynamic dispatch.
type IParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamListContext differentiates from other interfaces.
	IsParamListContext()
}

type ParamListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamListContext() *ParamListContext {
	var p = new(ParamListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_paramList
	return p
}

func (*ParamListContext) IsParamListContext() {}

func NewParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamListContext {
	var p = new(ParamListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_paramList

	return p
}

func (s *ParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamListContext) AllNCName() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserNCName)
}

func (s *ParamListContext) NCName(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserNCName, i)
}

func (s *ParamListContext) AllK_AS() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_AS)
}

func (s *ParamListContext) K_AS(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, i)
}

func (s *ParamListContext) AllSequenceType() []ISequenceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem())
	var tst = make([]ISequenceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequenceTypeContext)
		}
	}

	return tst
}

func (s *ParamListContext) SequenceType(i int) ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *ParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterParamList(s)
	}
}

func (s *ParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitParamList(s)
	}
}

func (p *jsoniqParser) ParamList() (localctx IParamListContext) {
	localctx = NewParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, jsoniqParserRULE_paramList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(289)
		p.Match(jsoniqParserT__9)
	}
	{
		p.SetState(290)
		p.Match(jsoniqParserNCName)
	}
	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_AS {
		{
			p.SetState(291)
			p.Match(jsoniqParserK_AS)
		}
		{
			p.SetState(292)
			p.SequenceType()
		}

	}
	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserT__3 {
		{
			p.SetState(295)
			p.Match(jsoniqParserT__3)
		}
		{
			p.SetState(296)
			p.Match(jsoniqParserT__9)
		}
		{
			p.SetState(297)
			p.Match(jsoniqParserNCName)
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_AS {
			{
				p.SetState(298)
				p.Match(jsoniqParserK_AS)
			}
			{
				p.SetState(299)
				p.SequenceType()
			}

		}

		p.SetState(306)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllExprSingle() []IExprSingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprSingleContext)(nil)).Elem())
	var tst = make([]IExprSingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprSingleContext)
		}
	}

	return tst
}

func (s *ExprContext) ExprSingle(i int) IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *jsoniqParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, jsoniqParserRULE_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(307)
		p.ExprSingle()
	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserT__3 {
		{
			p.SetState(308)
			p.Match(jsoniqParserT__3)
		}
		{
			p.SetState(309)
			p.ExprSingle()
		}

		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExprSingleContext is an interface to support dynamic dispatch.
type IExprSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprSingleContext differentiates from other interfaces.
	IsExprSingleContext()
}

type ExprSingleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprSingleContext() *ExprSingleContext {
	var p = new(ExprSingleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_exprSingle
	return p
}

func (*ExprSingleContext) IsExprSingleContext() {}

func NewExprSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprSingleContext {
	var p = new(ExprSingleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_exprSingle

	return p
}

func (s *ExprSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprSingleContext) FlowrExpr() IFlowrExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlowrExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlowrExprContext)
}

func (s *ExprSingleContext) QuantifiedExpr() IQuantifiedExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantifiedExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantifiedExprContext)
}

func (s *ExprSingleContext) SwitchExpr() ISwitchExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchExprContext)
}

func (s *ExprSingleContext) TypeswitchExpr() ITypeswitchExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeswitchExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeswitchExprContext)
}

func (s *ExprSingleContext) IfExpr() IIfExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExprContext)
}

func (s *ExprSingleContext) TryCatchExpr() ITryCatchExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryCatchExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryCatchExprContext)
}

func (s *ExprSingleContext) OrExpr() IOrExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrExprContext)
}

func (s *ExprSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterExprSingle(s)
	}
}

func (s *ExprSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitExprSingle(s)
	}
}

func (p *jsoniqParser) ExprSingle() (localctx IExprSingleContext) {
	localctx = NewExprSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, jsoniqParserRULE_exprSingle)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(322)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserK_FOR, jsoniqParserK_LET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(315)
			p.FlowrExpr()
		}

	case jsoniqParserK_SOME, jsoniqParserK_EVERY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(316)
			p.QuantifiedExpr()
		}

	case jsoniqParserK_SWITCH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(317)
			p.SwitchExpr()
		}

	case jsoniqParserK_TYPESWITCH:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(318)
			p.TypeswitchExpr()
		}

	case jsoniqParserK_IF:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(319)
			p.IfExpr()
		}

	case jsoniqParserK_TRY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(320)
			p.TryCatchExpr()
		}

	case jsoniqParserT__5, jsoniqParserT__7, jsoniqParserT__9, jsoniqParserT__18, jsoniqParserT__19, jsoniqParserT__22, jsoniqParserT__25, jsoniqParserT__26, jsoniqParserT__28, jsoniqParserT__29, jsoniqParserT__30, jsoniqParserK_ORDERED, jsoniqParserK_UNORDERED, jsoniqParserK_NOT, jsoniqParserIntegerLiteral, jsoniqParserDecimalLiteral, jsoniqParserDoubleLiteral, jsoniqParserStringLiteral, jsoniqParserNCName:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(321)
			p.OrExpr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFlowrExprContext is an interface to support dynamic dispatch.
type IFlowrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlowrExprContext differentiates from other interfaces.
	IsFlowrExprContext()
}

type FlowrExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlowrExprContext() *FlowrExprContext {
	var p = new(FlowrExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_flowrExpr
	return p
}

func (*FlowrExprContext) IsFlowrExprContext() {}

func NewFlowrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlowrExprContext {
	var p = new(FlowrExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_flowrExpr

	return p
}

func (s *FlowrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FlowrExprContext) K_RETURN() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_RETURN, 0)
}

func (s *FlowrExprContext) ExprSingle() IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *FlowrExprContext) AllForClause() []IForClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForClauseContext)(nil)).Elem())
	var tst = make([]IForClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForClauseContext)
		}
	}

	return tst
}

func (s *FlowrExprContext) ForClause(i int) IForClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForClauseContext)
}

func (s *FlowrExprContext) AllLetClause() []ILetClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILetClauseContext)(nil)).Elem())
	var tst = make([]ILetClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILetClauseContext)
		}
	}

	return tst
}

func (s *FlowrExprContext) LetClause(i int) ILetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILetClauseContext)
}

func (s *FlowrExprContext) AllWhereClause() []IWhereClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem())
	var tst = make([]IWhereClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhereClauseContext)
		}
	}

	return tst
}

func (s *FlowrExprContext) WhereClause(i int) IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *FlowrExprContext) AllGroupByClause() []IGroupByClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupByClauseContext)(nil)).Elem())
	var tst = make([]IGroupByClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupByClauseContext)
		}
	}

	return tst
}

func (s *FlowrExprContext) GroupByClause(i int) IGroupByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *FlowrExprContext) AllOrderByClause() []IOrderByClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem())
	var tst = make([]IOrderByClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderByClauseContext)
		}
	}

	return tst
}

func (s *FlowrExprContext) OrderByClause(i int) IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *FlowrExprContext) AllCountClause() []ICountClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICountClauseContext)(nil)).Elem())
	var tst = make([]ICountClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICountClauseContext)
		}
	}

	return tst
}

func (s *FlowrExprContext) CountClause(i int) ICountClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICountClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICountClauseContext)
}

func (s *FlowrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlowrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlowrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterFlowrExpr(s)
	}
}

func (s *FlowrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitFlowrExpr(s)
	}
}

func (p *jsoniqParser) FlowrExpr() (localctx IFlowrExprContext) {
	localctx = NewFlowrExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, jsoniqParserRULE_flowrExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(326)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserK_FOR:
		{
			p.SetState(324)
			p.ForClause()
		}

	case jsoniqParserK_LET:
		{
			p.SetState(325)
			p.LetClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(336)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(jsoniqParserK_ORDER-43))|(1<<(jsoniqParserK_STABLE-43))|(1<<(jsoniqParserK_FOR-43))|(1<<(jsoniqParserK_LET-43))|(1<<(jsoniqParserK_COUNT-43))|(1<<(jsoniqParserK_WHERE-43))|(1<<(jsoniqParserK_GROUP-43)))) != 0 {
		p.SetState(334)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case jsoniqParserK_FOR:
			{
				p.SetState(328)
				p.ForClause()
			}

		case jsoniqParserK_LET:
			{
				p.SetState(329)
				p.LetClause()
			}

		case jsoniqParserK_WHERE:
			{
				p.SetState(330)
				p.WhereClause()
			}

		case jsoniqParserK_GROUP:
			{
				p.SetState(331)
				p.GroupByClause()
			}

		case jsoniqParserK_ORDER, jsoniqParserK_STABLE:
			{
				p.SetState(332)
				p.OrderByClause()
			}

		case jsoniqParserK_COUNT:
			{
				p.SetState(333)
				p.CountClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(339)
		p.Match(jsoniqParserK_RETURN)
	}
	{
		p.SetState(340)
		p.ExprSingle()
	}

	return localctx
}

// IForClauseContext is an interface to support dynamic dispatch.
type IForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForClauseContext differentiates from other interfaces.
	IsForClauseContext()
}

type ForClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForClauseContext() *ForClauseContext {
	var p = new(ForClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_forClause
	return p
}

func (*ForClauseContext) IsForClauseContext() {}

func NewForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForClauseContext {
	var p = new(ForClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_forClause

	return p
}

func (s *ForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ForClauseContext) K_FOR() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_FOR, 0)
}

func (s *ForClauseContext) AllVarRef() []IVarRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVarRefContext)(nil)).Elem())
	var tst = make([]IVarRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVarRefContext)
		}
	}

	return tst
}

func (s *ForClauseContext) VarRef(i int) IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *ForClauseContext) AllK_IN() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_IN)
}

func (s *ForClauseContext) K_IN(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_IN, i)
}

func (s *ForClauseContext) AllExprSingle() []IExprSingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprSingleContext)(nil)).Elem())
	var tst = make([]IExprSingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprSingleContext)
		}
	}

	return tst
}

func (s *ForClauseContext) ExprSingle(i int) IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ForClauseContext) AllK_AS() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_AS)
}

func (s *ForClauseContext) K_AS(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, i)
}

func (s *ForClauseContext) AllSequenceType() []ISequenceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem())
	var tst = make([]ISequenceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequenceTypeContext)
		}
	}

	return tst
}

func (s *ForClauseContext) SequenceType(i int) ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *ForClauseContext) AllK_ALLOWING() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_ALLOWING)
}

func (s *ForClauseContext) K_ALLOWING(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ALLOWING, i)
}

func (s *ForClauseContext) AllK_EMPTY() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_EMPTY)
}

func (s *ForClauseContext) K_EMPTY(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_EMPTY, i)
}

func (s *ForClauseContext) AllK_AT() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_AT)
}

func (s *ForClauseContext) K_AT(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AT, i)
}

func (s *ForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterForClause(s)
	}
}

func (s *ForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitForClause(s)
	}
}

func (p *jsoniqParser) ForClause() (localctx IForClauseContext) {
	localctx = NewForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, jsoniqParserRULE_forClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(342)
		p.Match(jsoniqParserK_FOR)
	}
	{
		p.SetState(343)
		p.VarRef()
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_AS {
		{
			p.SetState(344)
			p.Match(jsoniqParserK_AS)
		}
		{
			p.SetState(345)
			p.SequenceType()
		}

	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_ALLOWING {
		{
			p.SetState(348)
			p.Match(jsoniqParserK_ALLOWING)
		}
		{
			p.SetState(349)
			p.Match(jsoniqParserK_EMPTY)
		}

	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_AT {
		{
			p.SetState(352)
			p.Match(jsoniqParserK_AT)
		}
		{
			p.SetState(353)
			p.VarRef()
		}

	}
	{
		p.SetState(356)
		p.Match(jsoniqParserK_IN)
	}
	{
		p.SetState(357)
		p.ExprSingle()
	}
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserT__3 {
		{
			p.SetState(358)
			p.Match(jsoniqParserT__3)
		}
		{
			p.SetState(359)
			p.VarRef()
		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_AS {
			{
				p.SetState(360)
				p.Match(jsoniqParserK_AS)
			}
			{
				p.SetState(361)
				p.SequenceType()
			}

		}
		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_ALLOWING {
			{
				p.SetState(364)
				p.Match(jsoniqParserK_ALLOWING)
			}
			{
				p.SetState(365)
				p.Match(jsoniqParserK_EMPTY)
			}

		}
		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_AT {
			{
				p.SetState(368)
				p.Match(jsoniqParserK_AT)
			}
			{
				p.SetState(369)
				p.VarRef()
			}

		}
		{
			p.SetState(372)
			p.Match(jsoniqParserK_IN)
		}
		{
			p.SetState(373)
			p.ExprSingle()
		}

		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILetClauseContext is an interface to support dynamic dispatch.
type ILetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLetClauseContext differentiates from other interfaces.
	IsLetClauseContext()
}

type LetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetClauseContext() *LetClauseContext {
	var p = new(LetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_letClause
	return p
}

func (*LetClauseContext) IsLetClauseContext() {}

func NewLetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetClauseContext {
	var p = new(LetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_letClause

	return p
}

func (s *LetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LetClauseContext) K_LET() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_LET, 0)
}

func (s *LetClauseContext) AllVarRef() []IVarRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVarRefContext)(nil)).Elem())
	var tst = make([]IVarRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVarRefContext)
		}
	}

	return tst
}

func (s *LetClauseContext) VarRef(i int) IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *LetClauseContext) AllExprSingle() []IExprSingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprSingleContext)(nil)).Elem())
	var tst = make([]IExprSingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprSingleContext)
		}
	}

	return tst
}

func (s *LetClauseContext) ExprSingle(i int) IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *LetClauseContext) AllK_AS() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_AS)
}

func (s *LetClauseContext) K_AS(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, i)
}

func (s *LetClauseContext) AllSequenceType() []ISequenceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem())
	var tst = make([]ISequenceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequenceTypeContext)
		}
	}

	return tst
}

func (s *LetClauseContext) SequenceType(i int) ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *LetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterLetClause(s)
	}
}

func (s *LetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitLetClause(s)
	}
}

func (p *jsoniqParser) LetClause() (localctx ILetClauseContext) {
	localctx = NewLetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, jsoniqParserRULE_letClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(jsoniqParserK_LET)
	}
	{
		p.SetState(381)
		p.VarRef()
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_AS {
		{
			p.SetState(382)
			p.Match(jsoniqParserK_AS)
		}
		{
			p.SetState(383)
			p.SequenceType()
		}

	}
	{
		p.SetState(386)
		p.Match(jsoniqParserT__4)
	}
	{
		p.SetState(387)
		p.ExprSingle()
	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserT__3 {
		{
			p.SetState(388)
			p.Match(jsoniqParserT__3)
		}
		{
			p.SetState(389)
			p.VarRef()
		}
		p.SetState(392)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_AS {
			{
				p.SetState(390)
				p.Match(jsoniqParserK_AS)
			}
			{
				p.SetState(391)
				p.SequenceType()
			}

		}
		{
			p.SetState(394)
			p.Match(jsoniqParserT__4)
		}
		{
			p.SetState(395)
			p.ExprSingle()
		}

		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICountClauseContext is an interface to support dynamic dispatch.
type ICountClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCountClauseContext differentiates from other interfaces.
	IsCountClauseContext()
}

type CountClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCountClauseContext() *CountClauseContext {
	var p = new(CountClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_countClause
	return p
}

func (*CountClauseContext) IsCountClauseContext() {}

func NewCountClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CountClauseContext {
	var p = new(CountClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_countClause

	return p
}

func (s *CountClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CountClauseContext) K_COUNT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_COUNT, 0)
}

func (s *CountClauseContext) VarRef() IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *CountClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CountClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CountClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterCountClause(s)
	}
}

func (s *CountClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitCountClause(s)
	}
}

func (p *jsoniqParser) CountClause() (localctx ICountClauseContext) {
	localctx = NewCountClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, jsoniqParserRULE_countClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Match(jsoniqParserK_COUNT)
	}
	{
		p.SetState(403)
		p.VarRef()
	}

	return localctx
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_whereClause
	return p
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) K_WHERE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_WHERE, 0)
}

func (s *WhereClauseContext) ExprSingle() IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *jsoniqParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, jsoniqParserRULE_whereClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.Match(jsoniqParserK_WHERE)
	}
	{
		p.SetState(406)
		p.ExprSingle()
	}

	return localctx
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_groupByClause
	return p
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) K_GROUP() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GROUP, 0)
}

func (s *GroupByClauseContext) K_BY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_BY, 0)
}

func (s *GroupByClauseContext) AllVarRef() []IVarRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVarRefContext)(nil)).Elem())
	var tst = make([]IVarRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVarRefContext)
		}
	}

	return tst
}

func (s *GroupByClauseContext) VarRef(i int) IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *GroupByClauseContext) AllExprSingle() []IExprSingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprSingleContext)(nil)).Elem())
	var tst = make([]IExprSingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprSingleContext)
		}
	}

	return tst
}

func (s *GroupByClauseContext) ExprSingle(i int) IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *GroupByClauseContext) AllK_COLLATION() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_COLLATION)
}

func (s *GroupByClauseContext) K_COLLATION(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_COLLATION, i)
}

func (s *GroupByClauseContext) AllUriLiteral() []IUriLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUriLiteralContext)(nil)).Elem())
	var tst = make([]IUriLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUriLiteralContext)
		}
	}

	return tst
}

func (s *GroupByClauseContext) UriLiteral(i int) IUriLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUriLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUriLiteralContext)
}

func (s *GroupByClauseContext) AllK_AS() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_AS)
}

func (s *GroupByClauseContext) K_AS(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, i)
}

func (s *GroupByClauseContext) AllSequenceType() []ISequenceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem())
	var tst = make([]ISequenceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequenceTypeContext)
		}
	}

	return tst
}

func (s *GroupByClauseContext) SequenceType(i int) ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (p *jsoniqParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, jsoniqParserRULE_groupByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(408)
		p.Match(jsoniqParserK_GROUP)
	}
	{
		p.SetState(409)
		p.Match(jsoniqParserK_BY)
	}
	{
		p.SetState(410)
		p.VarRef()
	}
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserT__4 || _la == jsoniqParserK_AS {
		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_AS {
			{
				p.SetState(411)
				p.Match(jsoniqParserK_AS)
			}
			{
				p.SetState(412)
				p.SequenceType()
			}

		}
		{
			p.SetState(415)
			p.Match(jsoniqParserT__4)
		}
		{
			p.SetState(416)
			p.ExprSingle()
		}

	}
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_COLLATION {
		{
			p.SetState(419)
			p.Match(jsoniqParserK_COLLATION)
		}
		{
			p.SetState(420)
			p.UriLiteral()
		}

	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserT__3 {
		{
			p.SetState(423)
			p.Match(jsoniqParserT__3)
		}
		{
			p.SetState(424)
			p.VarRef()
		}
		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserT__4 || _la == jsoniqParserK_AS {
			p.SetState(427)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == jsoniqParserK_AS {
				{
					p.SetState(425)
					p.Match(jsoniqParserK_AS)
				}
				{
					p.SetState(426)
					p.SequenceType()
				}

			}
			{
				p.SetState(429)
				p.Match(jsoniqParserT__4)
			}
			{
				p.SetState(430)
				p.ExprSingle()
			}

		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_COLLATION {
			{
				p.SetState(433)
				p.Match(jsoniqParserK_COLLATION)
			}
			{
				p.SetState(434)
				p.UriLiteral()
			}

		}

		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_orderByClause
	return p
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) AllExprSingle() []IExprSingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprSingleContext)(nil)).Elem())
	var tst = make([]IExprSingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprSingleContext)
		}
	}

	return tst
}

func (s *OrderByClauseContext) ExprSingle(i int) IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *OrderByClauseContext) AllK_EMPTY() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_EMPTY)
}

func (s *OrderByClauseContext) K_EMPTY(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_EMPTY, i)
}

func (s *OrderByClauseContext) AllK_COLLATION() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_COLLATION)
}

func (s *OrderByClauseContext) K_COLLATION(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_COLLATION, i)
}

func (s *OrderByClauseContext) AllUriLiteral() []IUriLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUriLiteralContext)(nil)).Elem())
	var tst = make([]IUriLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUriLiteralContext)
		}
	}

	return tst
}

func (s *OrderByClauseContext) UriLiteral(i int) IUriLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUriLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUriLiteralContext)
}

func (s *OrderByClauseContext) K_ORDER() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ORDER, 0)
}

func (s *OrderByClauseContext) K_BY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_BY, 0)
}

func (s *OrderByClauseContext) K_STABLE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_STABLE, 0)
}

func (s *OrderByClauseContext) AllK_ASCENDING() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_ASCENDING)
}

func (s *OrderByClauseContext) K_ASCENDING(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ASCENDING, i)
}

func (s *OrderByClauseContext) AllK_DESCENDING() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_DESCENDING)
}

func (s *OrderByClauseContext) K_DESCENDING(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DESCENDING, i)
}

func (s *OrderByClauseContext) AllK_GREATEST() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_GREATEST)
}

func (s *OrderByClauseContext) K_GREATEST(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GREATEST, i)
}

func (s *OrderByClauseContext) AllK_LEAST() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_LEAST)
}

func (s *OrderByClauseContext) K_LEAST(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_LEAST, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (p *jsoniqParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, jsoniqParserRULE_orderByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(447)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserK_ORDER:
		{
			p.SetState(442)
			p.Match(jsoniqParserK_ORDER)
		}
		{
			p.SetState(443)
			p.Match(jsoniqParserK_BY)
		}

	case jsoniqParserK_STABLE:
		{
			p.SetState(444)
			p.Match(jsoniqParserK_STABLE)
		}
		{
			p.SetState(445)
			p.Match(jsoniqParserK_ORDER)
		}
		{
			p.SetState(446)
			p.Match(jsoniqParserK_BY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(449)
		p.ExprSingle()
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_ASCENDING || _la == jsoniqParserK_DESCENDING {
		{
			p.SetState(450)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jsoniqParserK_ASCENDING || _la == jsoniqParserK_DESCENDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_EMPTY {
		{
			p.SetState(453)
			p.Match(jsoniqParserK_EMPTY)
		}
		{
			p.SetState(454)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jsoniqParserK_GREATEST || _la == jsoniqParserK_LEAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_COLLATION {
		{
			p.SetState(457)
			p.Match(jsoniqParserK_COLLATION)
		}
		{
			p.SetState(458)
			p.UriLiteral()
		}

	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserT__3 {
		{
			p.SetState(461)
			p.Match(jsoniqParserT__3)
		}
		{
			p.SetState(462)
			p.ExprSingle()
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_ASCENDING || _la == jsoniqParserK_DESCENDING {
			{
				p.SetState(463)
				_la = p.GetTokenStream().LA(1)

				if !(_la == jsoniqParserK_ASCENDING || _la == jsoniqParserK_DESCENDING) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(468)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_EMPTY {
			{
				p.SetState(466)
				p.Match(jsoniqParserK_EMPTY)
			}
			{
				p.SetState(467)
				_la = p.GetTokenStream().LA(1)

				if !(_la == jsoniqParserK_GREATEST || _la == jsoniqParserK_LEAST) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(472)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_COLLATION {
			{
				p.SetState(470)
				p.Match(jsoniqParserK_COLLATION)
			}
			{
				p.SetState(471)
				p.UriLiteral()
			}

		}

		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IQuantifiedExprContext is an interface to support dynamic dispatch.
type IQuantifiedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantifiedExprContext differentiates from other interfaces.
	IsQuantifiedExprContext()
}

type QuantifiedExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifiedExprContext() *QuantifiedExprContext {
	var p = new(QuantifiedExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_quantifiedExpr
	return p
}

func (*QuantifiedExprContext) IsQuantifiedExprContext() {}

func NewQuantifiedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifiedExprContext {
	var p = new(QuantifiedExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_quantifiedExpr

	return p
}

func (s *QuantifiedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifiedExprContext) AllVarRef() []IVarRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVarRefContext)(nil)).Elem())
	var tst = make([]IVarRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVarRefContext)
		}
	}

	return tst
}

func (s *QuantifiedExprContext) VarRef(i int) IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *QuantifiedExprContext) AllK_IN() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_IN)
}

func (s *QuantifiedExprContext) K_IN(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_IN, i)
}

func (s *QuantifiedExprContext) AllExprSingle() []IExprSingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprSingleContext)(nil)).Elem())
	var tst = make([]IExprSingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprSingleContext)
		}
	}

	return tst
}

func (s *QuantifiedExprContext) ExprSingle(i int) IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *QuantifiedExprContext) K_SATISFIES() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_SATISFIES, 0)
}

func (s *QuantifiedExprContext) K_SOME() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_SOME, 0)
}

func (s *QuantifiedExprContext) K_EVERY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_EVERY, 0)
}

func (s *QuantifiedExprContext) AllK_AS() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_AS)
}

func (s *QuantifiedExprContext) K_AS(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, i)
}

func (s *QuantifiedExprContext) AllSequenceType() []ISequenceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem())
	var tst = make([]ISequenceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequenceTypeContext)
		}
	}

	return tst
}

func (s *QuantifiedExprContext) SequenceType(i int) ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *QuantifiedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifiedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterQuantifiedExpr(s)
	}
}

func (s *QuantifiedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitQuantifiedExpr(s)
	}
}

func (p *jsoniqParser) QuantifiedExpr() (localctx IQuantifiedExprContext) {
	localctx = NewQuantifiedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, jsoniqParserRULE_quantifiedExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(479)
		_la = p.GetTokenStream().LA(1)

		if !(_la == jsoniqParserK_SOME || _la == jsoniqParserK_EVERY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(480)
		p.VarRef()
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_AS {
		{
			p.SetState(481)
			p.Match(jsoniqParserK_AS)
		}
		{
			p.SetState(482)
			p.SequenceType()
		}

	}
	{
		p.SetState(485)
		p.Match(jsoniqParserK_IN)
	}
	{
		p.SetState(486)
		p.ExprSingle()
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserT__3 {
		{
			p.SetState(487)
			p.Match(jsoniqParserT__3)
		}
		{
			p.SetState(488)
			p.VarRef()
		}
		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == jsoniqParserK_AS {
			{
				p.SetState(489)
				p.Match(jsoniqParserK_AS)
			}
			{
				p.SetState(490)
				p.SequenceType()
			}

		}
		{
			p.SetState(493)
			p.Match(jsoniqParserK_IN)
		}
		{
			p.SetState(494)
			p.ExprSingle()
		}

		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(501)
		p.Match(jsoniqParserK_SATISFIES)
	}
	{
		p.SetState(502)
		p.ExprSingle()
	}

	return localctx
}

// ISwitchExprContext is an interface to support dynamic dispatch.
type ISwitchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchExprContext differentiates from other interfaces.
	IsSwitchExprContext()
}

type SwitchExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchExprContext() *SwitchExprContext {
	var p = new(SwitchExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_switchExpr
	return p
}

func (*SwitchExprContext) IsSwitchExprContext() {}

func NewSwitchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchExprContext {
	var p = new(SwitchExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_switchExpr

	return p
}

func (s *SwitchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchExprContext) K_SWITCH() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_SWITCH, 0)
}

func (s *SwitchExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SwitchExprContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DEFAULT, 0)
}

func (s *SwitchExprContext) K_RETURN() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_RETURN, 0)
}

func (s *SwitchExprContext) ExprSingle() IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SwitchExprContext) AllSwitchCaseClause() []ISwitchCaseClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchCaseClauseContext)(nil)).Elem())
	var tst = make([]ISwitchCaseClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchCaseClauseContext)
		}
	}

	return tst
}

func (s *SwitchExprContext) SwitchCaseClause(i int) ISwitchCaseClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchCaseClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchCaseClauseContext)
}

func (s *SwitchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterSwitchExpr(s)
	}
}

func (s *SwitchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitSwitchExpr(s)
	}
}

func (p *jsoniqParser) SwitchExpr() (localctx ISwitchExprContext) {
	localctx = NewSwitchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, jsoniqParserRULE_switchExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)
		p.Match(jsoniqParserK_SWITCH)
	}
	{
		p.SetState(505)
		p.Match(jsoniqParserT__5)
	}
	{
		p.SetState(506)
		p.Expr()
	}
	{
		p.SetState(507)
		p.Match(jsoniqParserT__6)
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == jsoniqParserK_CASE {
		{
			p.SetState(508)
			p.SwitchCaseClause()
		}

		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(513)
		p.Match(jsoniqParserK_DEFAULT)
	}
	{
		p.SetState(514)
		p.Match(jsoniqParserK_RETURN)
	}
	{
		p.SetState(515)
		p.ExprSingle()
	}

	return localctx
}

// ISwitchCaseClauseContext is an interface to support dynamic dispatch.
type ISwitchCaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchCaseClauseContext differentiates from other interfaces.
	IsSwitchCaseClauseContext()
}

type SwitchCaseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchCaseClauseContext() *SwitchCaseClauseContext {
	var p = new(SwitchCaseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_switchCaseClause
	return p
}

func (*SwitchCaseClauseContext) IsSwitchCaseClauseContext() {}

func NewSwitchCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchCaseClauseContext {
	var p = new(SwitchCaseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_switchCaseClause

	return p
}

func (s *SwitchCaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchCaseClauseContext) K_RETURN() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_RETURN, 0)
}

func (s *SwitchCaseClauseContext) AllExprSingle() []IExprSingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprSingleContext)(nil)).Elem())
	var tst = make([]IExprSingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprSingleContext)
		}
	}

	return tst
}

func (s *SwitchCaseClauseContext) ExprSingle(i int) IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *SwitchCaseClauseContext) AllK_CASE() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_CASE)
}

func (s *SwitchCaseClauseContext) K_CASE(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_CASE, i)
}

func (s *SwitchCaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchCaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterSwitchCaseClause(s)
	}
}

func (s *SwitchCaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitSwitchCaseClause(s)
	}
}

func (p *jsoniqParser) SwitchCaseClause() (localctx ISwitchCaseClauseContext) {
	localctx = NewSwitchCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, jsoniqParserRULE_switchCaseClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == jsoniqParserK_CASE {
		{
			p.SetState(517)
			p.Match(jsoniqParserK_CASE)
		}
		{
			p.SetState(518)
			p.ExprSingle()
		}

		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(523)
		p.Match(jsoniqParserK_RETURN)
	}
	{
		p.SetState(524)
		p.ExprSingle()
	}

	return localctx
}

// ITypeswitchExprContext is an interface to support dynamic dispatch.
type ITypeswitchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeswitchExprContext differentiates from other interfaces.
	IsTypeswitchExprContext()
}

type TypeswitchExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeswitchExprContext() *TypeswitchExprContext {
	var p = new(TypeswitchExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_typeswitchExpr
	return p
}

func (*TypeswitchExprContext) IsTypeswitchExprContext() {}

func NewTypeswitchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeswitchExprContext {
	var p = new(TypeswitchExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_typeswitchExpr

	return p
}

func (s *TypeswitchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeswitchExprContext) K_TYPESWITCH() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_TYPESWITCH, 0)
}

func (s *TypeswitchExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TypeswitchExprContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DEFAULT, 0)
}

func (s *TypeswitchExprContext) K_RETURN() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_RETURN, 0)
}

func (s *TypeswitchExprContext) ExprSingle() IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *TypeswitchExprContext) AllCaseClause() []ICaseClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseClauseContext)(nil)).Elem())
	var tst = make([]ICaseClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseClauseContext)
		}
	}

	return tst
}

func (s *TypeswitchExprContext) CaseClause(i int) ICaseClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *TypeswitchExprContext) VarRef() IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *TypeswitchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeswitchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeswitchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterTypeswitchExpr(s)
	}
}

func (s *TypeswitchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitTypeswitchExpr(s)
	}
}

func (p *jsoniqParser) TypeswitchExpr() (localctx ITypeswitchExprContext) {
	localctx = NewTypeswitchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, jsoniqParserRULE_typeswitchExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)
		p.Match(jsoniqParserK_TYPESWITCH)
	}
	{
		p.SetState(527)
		p.Match(jsoniqParserT__5)
	}
	{
		p.SetState(528)
		p.Expr()
	}
	{
		p.SetState(529)
		p.Match(jsoniqParserT__6)
	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == jsoniqParserK_CASE {
		{
			p.SetState(530)
			p.CaseClause()
		}

		p.SetState(533)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(535)
		p.Match(jsoniqParserK_DEFAULT)
	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserT__9 {
		{
			p.SetState(536)
			p.VarRef()
		}

	}
	{
		p.SetState(539)
		p.Match(jsoniqParserK_RETURN)
	}
	{
		p.SetState(540)
		p.ExprSingle()
	}

	return localctx
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_caseClause
	return p
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) K_CASE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_CASE, 0)
}

func (s *CaseClauseContext) AllSequenceType() []ISequenceTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem())
	var tst = make([]ISequenceTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequenceTypeContext)
		}
	}

	return tst
}

func (s *CaseClauseContext) SequenceType(i int) ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *CaseClauseContext) K_RETURN() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_RETURN, 0)
}

func (s *CaseClauseContext) ExprSingle() IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *CaseClauseContext) VarRef() IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *CaseClauseContext) K_AS() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, 0)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (p *jsoniqParser) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, jsoniqParserRULE_caseClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(jsoniqParserK_CASE)
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserT__9 {
		{
			p.SetState(543)
			p.VarRef()
		}
		{
			p.SetState(544)
			p.Match(jsoniqParserK_AS)
		}

	}
	{
		p.SetState(548)
		p.SequenceType()
	}
	p.SetState(553)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserT__10 {
		{
			p.SetState(549)
			p.Match(jsoniqParserT__10)
		}
		{
			p.SetState(550)
			p.SequenceType()
		}

		p.SetState(555)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(556)
		p.Match(jsoniqParserK_RETURN)
	}
	{
		p.SetState(557)
		p.ExprSingle()
	}

	return localctx
}

// IIfExprContext is an interface to support dynamic dispatch.
type IIfExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfExprContext differentiates from other interfaces.
	IsIfExprContext()
}

type IfExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExprContext() *IfExprContext {
	var p = new(IfExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_ifExpr
	return p
}

func (*IfExprContext) IsIfExprContext() {}

func NewIfExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExprContext {
	var p = new(IfExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_ifExpr

	return p
}

func (s *IfExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExprContext) K_IF() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_IF, 0)
}

func (s *IfExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfExprContext) K_THEN() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_THEN, 0)
}

func (s *IfExprContext) AllExprSingle() []IExprSingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprSingleContext)(nil)).Elem())
	var tst = make([]IExprSingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprSingleContext)
		}
	}

	return tst
}

func (s *IfExprContext) ExprSingle(i int) IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *IfExprContext) K_ELSE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ELSE, 0)
}

func (s *IfExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterIfExpr(s)
	}
}

func (s *IfExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitIfExpr(s)
	}
}

func (p *jsoniqParser) IfExpr() (localctx IIfExprContext) {
	localctx = NewIfExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, jsoniqParserRULE_ifExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(jsoniqParserK_IF)
	}
	{
		p.SetState(560)
		p.Match(jsoniqParserT__5)
	}
	{
		p.SetState(561)
		p.Expr()
	}
	{
		p.SetState(562)
		p.Match(jsoniqParserT__6)
	}
	{
		p.SetState(563)
		p.Match(jsoniqParserK_THEN)
	}
	{
		p.SetState(564)
		p.ExprSingle()
	}
	{
		p.SetState(565)
		p.Match(jsoniqParserK_ELSE)
	}
	{
		p.SetState(566)
		p.ExprSingle()
	}

	return localctx
}

// ITryCatchExprContext is an interface to support dynamic dispatch.
type ITryCatchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryCatchExprContext differentiates from other interfaces.
	IsTryCatchExprContext()
}

type TryCatchExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryCatchExprContext() *TryCatchExprContext {
	var p = new(TryCatchExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_tryCatchExpr
	return p
}

func (*TryCatchExprContext) IsTryCatchExprContext() {}

func NewTryCatchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryCatchExprContext {
	var p = new(TryCatchExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_tryCatchExpr

	return p
}

func (s *TryCatchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TryCatchExprContext) K_TRY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_TRY, 0)
}

func (s *TryCatchExprContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *TryCatchExprContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TryCatchExprContext) K_CATCH() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_CATCH, 0)
}

func (s *TryCatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryCatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterTryCatchExpr(s)
	}
}

func (s *TryCatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitTryCatchExpr(s)
	}
}

func (p *jsoniqParser) TryCatchExpr() (localctx ITryCatchExprContext) {
	localctx = NewTryCatchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, jsoniqParserRULE_tryCatchExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(568)
		p.Match(jsoniqParserK_TRY)
	}
	{
		p.SetState(569)
		p.Match(jsoniqParserT__7)
	}
	{
		p.SetState(570)
		p.Expr()
	}
	{
		p.SetState(571)
		p.Match(jsoniqParserT__8)
	}
	{
		p.SetState(572)
		p.Match(jsoniqParserK_CATCH)
	}
	{
		p.SetState(573)
		p.Match(jsoniqParserT__11)
	}
	{
		p.SetState(574)
		p.Match(jsoniqParserT__7)
	}
	{
		p.SetState(575)
		p.Expr()
	}
	{
		p.SetState(576)
		p.Match(jsoniqParserT__8)
	}

	return localctx
}

// IOrExprContext is an interface to support dynamic dispatch.
type IOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrExprContext differentiates from other interfaces.
	IsOrExprContext()
}

type OrExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrExprContext() *OrExprContext {
	var p = new(OrExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_orExpr
	return p
}

func (*OrExprContext) IsOrExprContext() {}

func NewOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrExprContext {
	var p = new(OrExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_orExpr

	return p
}

func (s *OrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrExprContext) AllAndExpr() []IAndExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAndExprContext)(nil)).Elem())
	var tst = make([]IAndExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAndExprContext)
		}
	}

	return tst
}

func (s *OrExprContext) AndExpr(i int) IAndExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAndExprContext)
}

func (s *OrExprContext) AllK_OR() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_OR)
}

func (s *OrExprContext) K_OR(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_OR, i)
}

func (s *OrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterOrExpr(s)
	}
}

func (s *OrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitOrExpr(s)
	}
}

func (p *jsoniqParser) OrExpr() (localctx IOrExprContext) {
	localctx = NewOrExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, jsoniqParserRULE_orExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(578)
		p.AndExpr()
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(579)
				p.Match(jsoniqParserK_OR)
			}
			{
				p.SetState(580)
				p.AndExpr()
			}

		}
		p.SetState(585)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}

	return localctx
}

// IAndExprContext is an interface to support dynamic dispatch.
type IAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndExprContext differentiates from other interfaces.
	IsAndExprContext()
}

type AndExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExprContext() *AndExprContext {
	var p = new(AndExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_andExpr
	return p
}

func (*AndExprContext) IsAndExprContext() {}

func NewAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExprContext {
	var p = new(AndExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_andExpr

	return p
}

func (s *AndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExprContext) AllNotExpr() []INotExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INotExprContext)(nil)).Elem())
	var tst = make([]INotExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INotExprContext)
		}
	}

	return tst
}

func (s *AndExprContext) NotExpr(i int) INotExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INotExprContext)
}

func (s *AndExprContext) AllK_AND() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_AND)
}

func (s *AndExprContext) K_AND(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AND, i)
}

func (s *AndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterAndExpr(s)
	}
}

func (s *AndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitAndExpr(s)
	}
}

func (p *jsoniqParser) AndExpr() (localctx IAndExprContext) {
	localctx = NewAndExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, jsoniqParserRULE_andExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.NotExpr()
	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(587)
				p.Match(jsoniqParserK_AND)
			}
			{
				p.SetState(588)
				p.NotExpr()
			}

		}
		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
	}

	return localctx
}

// INotExprContext is an interface to support dynamic dispatch.
type INotExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotExprContext differentiates from other interfaces.
	IsNotExprContext()
}

type NotExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotExprContext() *NotExprContext {
	var p = new(NotExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_notExpr
	return p
}

func (*NotExprContext) IsNotExprContext() {}

func NewNotExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotExprContext {
	var p = new(NotExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_notExpr

	return p
}

func (s *NotExprContext) GetParser() antlr.Parser { return s.parser }

func (s *NotExprContext) ComparisonExpr2() IComparisonExpr2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonExpr2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonExpr2Context)
}

func (s *NotExprContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_NOT, 0)
}

func (s *NotExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterNotExpr(s)
	}
}

func (s *NotExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitNotExpr(s)
	}
}

func (p *jsoniqParser) NotExpr() (localctx INotExprContext) {
	localctx = NewNotExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, jsoniqParserRULE_notExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == jsoniqParserK_NOT {
		{
			p.SetState(594)
			p.Match(jsoniqParserK_NOT)
		}

	}
	{
		p.SetState(597)
		p.ComparisonExpr2()
	}

	return localctx
}

// IComparisonExpr2Context is an interface to support dynamic dispatch.
type IComparisonExpr2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonExpr2Context differentiates from other interfaces.
	IsComparisonExpr2Context()
}

type ComparisonExpr2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExpr2Context() *ComparisonExpr2Context {
	var p = new(ComparisonExpr2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_comparisonExpr2
	return p
}

func (*ComparisonExpr2Context) IsComparisonExpr2Context() {}

func NewComparisonExpr2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExpr2Context {
	var p = new(ComparisonExpr2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_comparisonExpr2

	return p
}

func (s *ComparisonExpr2Context) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExpr2Context) AllComparisonExpr() []IComparisonExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComparisonExprContext)(nil)).Elem())
	var tst = make([]IComparisonExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComparisonExprContext)
		}
	}

	return tst
}

func (s *ComparisonExpr2Context) ComparisonExpr(i int) IComparisonExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *ComparisonExpr2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpr2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExpr2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterComparisonExpr2(s)
	}
}

func (s *ComparisonExpr2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitComparisonExpr2(s)
	}
}

func (p *jsoniqParser) ComparisonExpr2() (localctx IComparisonExpr2Context) {
	localctx = NewComparisonExpr2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, jsoniqParserRULE_comparisonExpr2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.ComparisonExpr()
	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(600)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<jsoniqParserT__1)|(1<<jsoniqParserT__12)|(1<<jsoniqParserT__13)|(1<<jsoniqParserT__14)|(1<<jsoniqParserT__15)|(1<<jsoniqParserT__16))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(601)
			p.ComparisonExpr()
		}

	}

	return localctx
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_comparisonExpr
	return p
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) AllStringConcatExpr() []IStringConcatExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringConcatExprContext)(nil)).Elem())
	var tst = make([]IStringConcatExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringConcatExprContext)
		}
	}

	return tst
}

func (s *ComparisonExprContext) StringConcatExpr(i int) IStringConcatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringConcatExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringConcatExprContext)
}

func (s *ComparisonExprContext) K_EQ() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_EQ, 0)
}

func (s *ComparisonExprContext) K_NE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_NE, 0)
}

func (s *ComparisonExprContext) K_LT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_LT, 0)
}

func (s *ComparisonExprContext) K_LE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_LE, 0)
}

func (s *ComparisonExprContext) K_GT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GT, 0)
}

func (s *ComparisonExprContext) K_GE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GE, 0)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (p *jsoniqParser) ComparisonExpr() (localctx IComparisonExprContext) {
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, jsoniqParserRULE_comparisonExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.StringConcatExpr()
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(605)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(jsoniqParserK_EQ-92))|(1<<(jsoniqParserK_NE-92))|(1<<(jsoniqParserK_LT-92))|(1<<(jsoniqParserK_LE-92))|(1<<(jsoniqParserK_GT-92))|(1<<(jsoniqParserK_GE-92)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(606)
			p.StringConcatExpr()
		}

	}

	return localctx
}

// IStringConcatExprContext is an interface to support dynamic dispatch.
type IStringConcatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringConcatExprContext differentiates from other interfaces.
	IsStringConcatExprContext()
}

type StringConcatExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringConcatExprContext() *StringConcatExprContext {
	var p = new(StringConcatExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_stringConcatExpr
	return p
}

func (*StringConcatExprContext) IsStringConcatExprContext() {}

func NewStringConcatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringConcatExprContext {
	var p = new(StringConcatExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_stringConcatExpr

	return p
}

func (s *StringConcatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StringConcatExprContext) AllRangeExpr() []IRangeExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRangeExprContext)(nil)).Elem())
	var tst = make([]IRangeExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRangeExprContext)
		}
	}

	return tst
}

func (s *StringConcatExprContext) RangeExpr(i int) IRangeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRangeExprContext)
}

func (s *StringConcatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringConcatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringConcatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterStringConcatExpr(s)
	}
}

func (s *StringConcatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitStringConcatExpr(s)
	}
}

func (p *jsoniqParser) StringConcatExpr() (localctx IStringConcatExprContext) {
	localctx = NewStringConcatExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, jsoniqParserRULE_stringConcatExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(609)
		p.RangeExpr()
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(610)
				p.Match(jsoniqParserT__17)
			}
			{
				p.SetState(611)
				p.RangeExpr()
			}

		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
	}

	return localctx
}

// IRangeExprContext is an interface to support dynamic dispatch.
type IRangeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeExprContext differentiates from other interfaces.
	IsRangeExprContext()
}

type RangeExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExprContext() *RangeExprContext {
	var p = new(RangeExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_rangeExpr
	return p
}

func (*RangeExprContext) IsRangeExprContext() {}

func NewRangeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExprContext {
	var p = new(RangeExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_rangeExpr

	return p
}

func (s *RangeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExprContext) AllAdditiveExpr() []IAdditiveExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditiveExprContext)(nil)).Elem())
	var tst = make([]IAdditiveExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditiveExprContext)
		}
	}

	return tst
}

func (s *RangeExprContext) AdditiveExpr(i int) IAdditiveExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *RangeExprContext) K_TO() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_TO, 0)
}

func (s *RangeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterRangeExpr(s)
	}
}

func (s *RangeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitRangeExpr(s)
	}
}

func (p *jsoniqParser) RangeExpr() (localctx IRangeExprContext) {
	localctx = NewRangeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, jsoniqParserRULE_rangeExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.AdditiveExpr()
	}
	p.SetState(620)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(618)
			p.Match(jsoniqParserK_TO)
		}
		{
			p.SetState(619)
			p.AdditiveExpr()
		}

	}

	return localctx
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_additiveExpr
	return p
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) AllMultiplicativeExpr() []IMultiplicativeExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicativeExprContext)(nil)).Elem())
	var tst = make([]IMultiplicativeExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicativeExprContext)
		}
	}

	return tst
}

func (s *AdditiveExprContext) MultiplicativeExpr(i int) IMultiplicativeExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (p *jsoniqParser) AdditiveExpr() (localctx IAdditiveExprContext) {
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, jsoniqParserRULE_additiveExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(622)
		p.MultiplicativeExpr()
	}
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(623)
				_la = p.GetTokenStream().LA(1)

				if !(_la == jsoniqParserT__18 || _la == jsoniqParserT__19) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(624)
				p.MultiplicativeExpr()
			}

		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
	}

	return localctx
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_multiplicativeExpr
	return p
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) AllInstanceofExpr() []IInstanceofExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstanceofExprContext)(nil)).Elem())
	var tst = make([]IInstanceofExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstanceofExprContext)
		}
	}

	return tst
}

func (s *MultiplicativeExprContext) InstanceofExpr(i int) IInstanceofExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstanceofExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstanceofExprContext)
}

func (s *MultiplicativeExprContext) AllK_DIV() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_DIV)
}

func (s *MultiplicativeExprContext) K_DIV(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DIV, i)
}

func (s *MultiplicativeExprContext) AllK_IDIV() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_IDIV)
}

func (s *MultiplicativeExprContext) K_IDIV(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_IDIV, i)
}

func (s *MultiplicativeExprContext) AllK_MOD() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserK_MOD)
}

func (s *MultiplicativeExprContext) K_MOD(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_MOD, i)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (p *jsoniqParser) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, jsoniqParserRULE_multiplicativeExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(630)
		p.InstanceofExpr()
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(631)
				_la = p.GetTokenStream().LA(1)

				if !(_la == jsoniqParserT__11 || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(jsoniqParserK_DIV-98))|(1<<(jsoniqParserK_IDIV-98))|(1<<(jsoniqParserK_MOD-98)))) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(632)
				p.InstanceofExpr()
			}

		}
		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())
	}

	return localctx
}

// IInstanceofExprContext is an interface to support dynamic dispatch.
type IInstanceofExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstanceofExprContext differentiates from other interfaces.
	IsInstanceofExprContext()
}

type InstanceofExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceofExprContext() *InstanceofExprContext {
	var p = new(InstanceofExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_instanceofExpr
	return p
}

func (*InstanceofExprContext) IsInstanceofExprContext() {}

func NewInstanceofExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceofExprContext {
	var p = new(InstanceofExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_instanceofExpr

	return p
}

func (s *InstanceofExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceofExprContext) TreatExpr() ITreatExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITreatExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITreatExprContext)
}

func (s *InstanceofExprContext) K_INSTANCE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_INSTANCE, 0)
}

func (s *InstanceofExprContext) K_OF() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_OF, 0)
}

func (s *InstanceofExprContext) SequenceType() ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *InstanceofExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceofExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterInstanceofExpr(s)
	}
}

func (s *InstanceofExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitInstanceofExpr(s)
	}
}

func (p *jsoniqParser) InstanceofExpr() (localctx IInstanceofExprContext) {
	localctx = NewInstanceofExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, jsoniqParserRULE_instanceofExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(638)
		p.TreatExpr()
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(639)
			p.Match(jsoniqParserK_INSTANCE)
		}
		{
			p.SetState(640)
			p.Match(jsoniqParserK_OF)
		}
		{
			p.SetState(641)
			p.SequenceType()
		}

	}

	return localctx
}

// ITreatExprContext is an interface to support dynamic dispatch.
type ITreatExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTreatExprContext differentiates from other interfaces.
	IsTreatExprContext()
}

type TreatExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTreatExprContext() *TreatExprContext {
	var p = new(TreatExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_treatExpr
	return p
}

func (*TreatExprContext) IsTreatExprContext() {}

func NewTreatExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TreatExprContext {
	var p = new(TreatExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_treatExpr

	return p
}

func (s *TreatExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TreatExprContext) CastableExpr() ICastableExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastableExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastableExprContext)
}

func (s *TreatExprContext) K_TREAT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_TREAT, 0)
}

func (s *TreatExprContext) K_AS() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, 0)
}

func (s *TreatExprContext) SequenceType() ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *TreatExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TreatExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TreatExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterTreatExpr(s)
	}
}

func (s *TreatExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitTreatExpr(s)
	}
}

func (p *jsoniqParser) TreatExpr() (localctx ITreatExprContext) {
	localctx = NewTreatExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, jsoniqParserRULE_treatExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.CastableExpr()
	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(645)
			p.Match(jsoniqParserK_TREAT)
		}
		{
			p.SetState(646)
			p.Match(jsoniqParserK_AS)
		}
		{
			p.SetState(647)
			p.SequenceType()
		}

	}

	return localctx
}

// ICastableExprContext is an interface to support dynamic dispatch.
type ICastableExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastableExprContext differentiates from other interfaces.
	IsCastableExprContext()
}

type CastableExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastableExprContext() *CastableExprContext {
	var p = new(CastableExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_castableExpr
	return p
}

func (*CastableExprContext) IsCastableExprContext() {}

func NewCastableExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastableExprContext {
	var p = new(CastableExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_castableExpr

	return p
}

func (s *CastableExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastableExprContext) CastExpr() ICastExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastExprContext)
}

func (s *CastableExprContext) K_CASTABLE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_CASTABLE, 0)
}

func (s *CastableExprContext) K_AS() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, 0)
}

func (s *CastableExprContext) AtomicType() IAtomicTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicTypeContext)
}

func (s *CastableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastableExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastableExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterCastableExpr(s)
	}
}

func (s *CastableExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitCastableExpr(s)
	}
}

func (p *jsoniqParser) CastableExpr() (localctx ICastableExprContext) {
	localctx = NewCastableExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, jsoniqParserRULE_castableExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.CastExpr()
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(651)
			p.Match(jsoniqParserK_CASTABLE)
		}
		{
			p.SetState(652)
			p.Match(jsoniqParserK_AS)
		}
		{
			p.SetState(653)
			p.AtomicType()
		}
		p.SetState(655)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(654)
				p.Match(jsoniqParserT__20)
			}

		}

	}

	return localctx
}

// ICastExprContext is an interface to support dynamic dispatch.
type ICastExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastExprContext differentiates from other interfaces.
	IsCastExprContext()
}

type CastExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExprContext() *CastExprContext {
	var p = new(CastExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_castExpr
	return p
}

func (*CastExprContext) IsCastExprContext() {}

func NewCastExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExprContext {
	var p = new(CastExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_castExpr

	return p
}

func (s *CastExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExprContext) UnaryExpr() IUnaryExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *CastExprContext) K_CAST() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_CAST, 0)
}

func (s *CastExprContext) K_AS() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_AS, 0)
}

func (s *CastExprContext) AtomicType() IAtomicTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicTypeContext)
}

func (s *CastExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterCastExpr(s)
	}
}

func (s *CastExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitCastExpr(s)
	}
}

func (p *jsoniqParser) CastExpr() (localctx ICastExprContext) {
	localctx = NewCastExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, jsoniqParserRULE_castExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.UnaryExpr()
	}
	p.SetState(666)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(660)
			p.Match(jsoniqParserK_CAST)
		}
		{
			p.SetState(661)
			p.Match(jsoniqParserK_AS)
		}
		{
			p.SetState(662)
			p.AtomicType()
		}
		p.SetState(664)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(663)
				p.Match(jsoniqParserT__20)
			}

		}

	}

	return localctx
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_unaryExpr
	return p
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) SimpleMapExpr() ISimpleMapExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleMapExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleMapExprContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterUnaryExpr(s)
	}
}

func (s *UnaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitUnaryExpr(s)
	}
}

func (p *jsoniqParser) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, jsoniqParserRULE_unaryExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == jsoniqParserT__18 || _la == jsoniqParserT__19 {
		{
			p.SetState(668)
			_la = p.GetTokenStream().LA(1)

			if !(_la == jsoniqParserT__18 || _la == jsoniqParserT__19) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(673)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(674)
		p.SimpleMapExpr()
	}

	return localctx
}

// ISimpleMapExprContext is an interface to support dynamic dispatch.
type ISimpleMapExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleMapExprContext differentiates from other interfaces.
	IsSimpleMapExprContext()
}

type SimpleMapExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleMapExprContext() *SimpleMapExprContext {
	var p = new(SimpleMapExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_simpleMapExpr
	return p
}

func (*SimpleMapExprContext) IsSimpleMapExprContext() {}

func NewSimpleMapExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleMapExprContext {
	var p = new(SimpleMapExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_simpleMapExpr

	return p
}

func (s *SimpleMapExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleMapExprContext) AllPostfixExpr() []IPostfixExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPostfixExprContext)(nil)).Elem())
	var tst = make([]IPostfixExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPostfixExprContext)
		}
	}

	return tst
}

func (s *SimpleMapExprContext) PostfixExpr(i int) IPostfixExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *SimpleMapExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleMapExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleMapExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterSimpleMapExpr(s)
	}
}

func (s *SimpleMapExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitSimpleMapExpr(s)
	}
}

func (p *jsoniqParser) SimpleMapExpr() (localctx ISimpleMapExprContext) {
	localctx = NewSimpleMapExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, jsoniqParserRULE_simpleMapExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.PostfixExpr()
	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(677)
				p.Match(jsoniqParserT__21)
			}
			{
				p.SetState(678)
				p.PostfixExpr()
			}

		}
		p.SetState(683)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())
	}

	return localctx
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_postfixExpr
	return p
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) AllPredicate() []IPredicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
	var tst = make([]IPredicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPredicateContext)
		}
	}

	return tst
}

func (s *PostfixExprContext) Predicate(i int) IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PostfixExprContext) AllObjectLookup() []IObjectLookupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObjectLookupContext)(nil)).Elem())
	var tst = make([]IObjectLookupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObjectLookupContext)
		}
	}

	return tst
}

func (s *PostfixExprContext) ObjectLookup(i int) IObjectLookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectLookupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObjectLookupContext)
}

func (s *PostfixExprContext) AllArrayLookup() []IArrayLookupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArrayLookupContext)(nil)).Elem())
	var tst = make([]IArrayLookupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArrayLookupContext)
		}
	}

	return tst
}

func (s *PostfixExprContext) ArrayLookup(i int) IArrayLookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayLookupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArrayLookupContext)
}

func (s *PostfixExprContext) AllArrayUnboxing() []IArrayUnboxingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArrayUnboxingContext)(nil)).Elem())
	var tst = make([]IArrayUnboxingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArrayUnboxingContext)
		}
	}

	return tst
}

func (s *PostfixExprContext) ArrayUnboxing(i int) IArrayUnboxingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayUnboxingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArrayUnboxingContext)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (p *jsoniqParser) PostfixExpr() (localctx IPostfixExprContext) {
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, jsoniqParserRULE_postfixExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		p.PrimaryExpr()
	}
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(689)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(685)
					p.Predicate()
				}

			case 2:
				{
					p.SetState(686)
					p.ObjectLookup()
				}

			case 3:
				{
					p.SetState(687)
					p.ArrayLookup()
				}

			case 4:
				{
					p.SetState(688)
					p.ArrayUnboxing()
				}

			}

		}
		p.SetState(693)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *jsoniqParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, jsoniqParserRULE_predicate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.Match(jsoniqParserT__22)
	}
	{
		p.SetState(695)
		p.Expr()
	}
	{
		p.SetState(696)
		p.Match(jsoniqParserT__23)
	}

	return localctx
}

// IObjectLookupContext is an interface to support dynamic dispatch.
type IObjectLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectLookupContext differentiates from other interfaces.
	IsObjectLookupContext()
}

type ObjectLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLookupContext() *ObjectLookupContext {
	var p = new(ObjectLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_objectLookup
	return p
}

func (*ObjectLookupContext) IsObjectLookupContext() {}

func NewObjectLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLookupContext {
	var p = new(ObjectLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_objectLookup

	return p
}

func (s *ObjectLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLookupContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(jsoniqParserStringLiteral, 0)
}

func (s *ObjectLookupContext) NCName() antlr.TerminalNode {
	return s.GetToken(jsoniqParserNCName, 0)
}

func (s *ObjectLookupContext) ParenthesizedExpr() IParenthesizedExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExprContext)
}

func (s *ObjectLookupContext) VarRef() IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *ObjectLookupContext) ContextItemExpr() IContextItemExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContextItemExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContextItemExprContext)
}

func (s *ObjectLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterObjectLookup(s)
	}
}

func (s *ObjectLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitObjectLookup(s)
	}
}

func (p *jsoniqParser) ObjectLookup() (localctx IObjectLookupContext) {
	localctx = NewObjectLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, jsoniqParserRULE_objectLookup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Match(jsoniqParserT__24)
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserStringLiteral:
		{
			p.SetState(699)
			p.Match(jsoniqParserStringLiteral)
		}

	case jsoniqParserNCName:
		{
			p.SetState(700)
			p.Match(jsoniqParserNCName)
		}

	case jsoniqParserT__5:
		{
			p.SetState(701)
			p.ParenthesizedExpr()
		}

	case jsoniqParserT__9:
		{
			p.SetState(702)
			p.VarRef()
		}

	case jsoniqParserT__25:
		{
			p.SetState(703)
			p.ContextItemExpr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayLookupContext is an interface to support dynamic dispatch.
type IArrayLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayLookupContext differentiates from other interfaces.
	IsArrayLookupContext()
}

type ArrayLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLookupContext() *ArrayLookupContext {
	var p = new(ArrayLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_arrayLookup
	return p
}

func (*ArrayLookupContext) IsArrayLookupContext() {}

func NewArrayLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLookupContext {
	var p = new(ArrayLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_arrayLookup

	return p
}

func (s *ArrayLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLookupContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ArrayLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterArrayLookup(s)
	}
}

func (s *ArrayLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitArrayLookup(s)
	}
}

func (p *jsoniqParser) ArrayLookup() (localctx IArrayLookupContext) {
	localctx = NewArrayLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, jsoniqParserRULE_arrayLookup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Match(jsoniqParserT__22)
	}
	{
		p.SetState(707)
		p.Match(jsoniqParserT__22)
	}
	{
		p.SetState(708)
		p.Expr()
	}
	{
		p.SetState(709)
		p.Match(jsoniqParserT__23)
	}
	{
		p.SetState(710)
		p.Match(jsoniqParserT__23)
	}

	return localctx
}

// IArrayUnboxingContext is an interface to support dynamic dispatch.
type IArrayUnboxingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayUnboxingContext differentiates from other interfaces.
	IsArrayUnboxingContext()
}

type ArrayUnboxingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayUnboxingContext() *ArrayUnboxingContext {
	var p = new(ArrayUnboxingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_arrayUnboxing
	return p
}

func (*ArrayUnboxingContext) IsArrayUnboxingContext() {}

func NewArrayUnboxingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayUnboxingContext {
	var p = new(ArrayUnboxingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_arrayUnboxing

	return p
}

func (s *ArrayUnboxingContext) GetParser() antlr.Parser { return s.parser }
func (s *ArrayUnboxingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayUnboxingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayUnboxingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterArrayUnboxing(s)
	}
}

func (s *ArrayUnboxingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitArrayUnboxing(s)
	}
}

func (p *jsoniqParser) ArrayUnboxing() (localctx IArrayUnboxingContext) {
	localctx = NewArrayUnboxingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, jsoniqParserRULE_arrayUnboxing)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Match(jsoniqParserT__22)
	}
	{
		p.SetState(713)
		p.Match(jsoniqParserT__23)
	}

	return localctx
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_primaryExpr
	return p
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExprContext) VarRef() IVarRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarRefContext)
}

func (s *PrimaryExprContext) ParenthesizedExpr() IParenthesizedExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExprContext)
}

func (s *PrimaryExprContext) ContextItemExpr() IContextItemExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContextItemExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContextItemExprContext)
}

func (s *PrimaryExprContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PrimaryExprContext) OrderedExpr() IOrderedExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderedExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderedExprContext)
}

func (s *PrimaryExprContext) UnorderedExpr() IUnorderedExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnorderedExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnorderedExprContext)
}

func (s *PrimaryExprContext) ObjectConstructor() IObjectConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectConstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectConstructorContext)
}

func (s *PrimaryExprContext) ArrayConstructor() IArrayConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayConstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayConstructorContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitPrimaryExpr(s)
	}
}

func (p *jsoniqParser) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, jsoniqParserRULE_primaryExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(724)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserT__28, jsoniqParserT__29, jsoniqParserT__30, jsoniqParserIntegerLiteral, jsoniqParserDecimalLiteral, jsoniqParserDoubleLiteral, jsoniqParserStringLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(715)
			p.Literal()
		}

	case jsoniqParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(716)
			p.VarRef()
		}

	case jsoniqParserT__5:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(717)
			p.ParenthesizedExpr()
		}

	case jsoniqParserT__25:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(718)
			p.ContextItemExpr()
		}

	case jsoniqParserNCName:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(719)
			p.FunctionCall()
		}

	case jsoniqParserK_ORDERED:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(720)
			p.OrderedExpr()
		}

	case jsoniqParserK_UNORDERED:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(721)
			p.UnorderedExpr()
		}

	case jsoniqParserT__7, jsoniqParserT__26:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(722)
			p.ObjectConstructor()
		}

	case jsoniqParserT__22:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(723)
			p.ArrayConstructor()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVarRefContext is an interface to support dynamic dispatch.
type IVarRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarRefContext differentiates from other interfaces.
	IsVarRefContext()
}

type VarRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarRefContext() *VarRefContext {
	var p = new(VarRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_varRef
	return p
}

func (*VarRefContext) IsVarRefContext() {}

func NewVarRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarRefContext {
	var p = new(VarRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_varRef

	return p
}

func (s *VarRefContext) GetParser() antlr.Parser { return s.parser }

func (s *VarRefContext) AllNCName() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserNCName)
}

func (s *VarRefContext) NCName(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserNCName, i)
}

func (s *VarRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterVarRef(s)
	}
}

func (s *VarRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitVarRef(s)
	}
}

func (p *jsoniqParser) VarRef() (localctx IVarRefContext) {
	localctx = NewVarRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, jsoniqParserRULE_varRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Match(jsoniqParserT__9)
	}
	p.SetState(729)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(727)
			p.Match(jsoniqParserNCName)
		}
		{
			p.SetState(728)
			p.Match(jsoniqParserT__2)
		}

	}
	{
		p.SetState(731)
		p.Match(jsoniqParserNCName)
	}

	return localctx
}

// IParenthesizedExprContext is an interface to support dynamic dispatch.
type IParenthesizedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedExprContext differentiates from other interfaces.
	IsParenthesizedExprContext()
}

type ParenthesizedExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExprContext() *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_parenthesizedExpr
	return p
}

func (*ParenthesizedExprContext) IsParenthesizedExprContext() {}

func NewParenthesizedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExprContext {
	var p = new(ParenthesizedExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_parenthesizedExpr

	return p
}

func (s *ParenthesizedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParenthesizedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterParenthesizedExpr(s)
	}
}

func (s *ParenthesizedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitParenthesizedExpr(s)
	}
}

func (p *jsoniqParser) ParenthesizedExpr() (localctx IParenthesizedExprContext) {
	localctx = NewParenthesizedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, jsoniqParserRULE_parenthesizedExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(733)
		p.Match(jsoniqParserT__5)
	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<jsoniqParserT__5)|(1<<jsoniqParserT__7)|(1<<jsoniqParserT__9)|(1<<jsoniqParserT__18)|(1<<jsoniqParserT__19)|(1<<jsoniqParserT__22)|(1<<jsoniqParserT__25)|(1<<jsoniqParserT__26)|(1<<jsoniqParserT__28)|(1<<jsoniqParserT__29)|(1<<jsoniqParserT__30))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(jsoniqParserK_ORDERED-39))|(1<<(jsoniqParserK_UNORDERED-39))|(1<<(jsoniqParserK_FOR-39))|(1<<(jsoniqParserK_LET-39)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(jsoniqParserK_SOME-78))|(1<<(jsoniqParserK_EVERY-78))|(1<<(jsoniqParserK_SWITCH-78))|(1<<(jsoniqParserK_TYPESWITCH-78))|(1<<(jsoniqParserK_IF-78))|(1<<(jsoniqParserK_TRY-78))|(1<<(jsoniqParserK_NOT-78)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(jsoniqParserIntegerLiteral-135))|(1<<(jsoniqParserDecimalLiteral-135))|(1<<(jsoniqParserDoubleLiteral-135))|(1<<(jsoniqParserStringLiteral-135))|(1<<(jsoniqParserNCName-135)))) != 0) {
		{
			p.SetState(734)
			p.Expr()
		}

	}
	{
		p.SetState(737)
		p.Match(jsoniqParserT__6)
	}

	return localctx
}

// IContextItemExprContext is an interface to support dynamic dispatch.
type IContextItemExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContextItemExprContext differentiates from other interfaces.
	IsContextItemExprContext()
}

type ContextItemExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextItemExprContext() *ContextItemExprContext {
	var p = new(ContextItemExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_contextItemExpr
	return p
}

func (*ContextItemExprContext) IsContextItemExprContext() {}

func NewContextItemExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextItemExprContext {
	var p = new(ContextItemExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_contextItemExpr

	return p
}

func (s *ContextItemExprContext) GetParser() antlr.Parser { return s.parser }
func (s *ContextItemExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextItemExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextItemExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterContextItemExpr(s)
	}
}

func (s *ContextItemExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitContextItemExpr(s)
	}
}

func (p *jsoniqParser) ContextItemExpr() (localctx IContextItemExprContext) {
	localctx = NewContextItemExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, jsoniqParserRULE_contextItemExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(jsoniqParserT__25)
	}

	return localctx
}

// IOrderedExprContext is an interface to support dynamic dispatch.
type IOrderedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderedExprContext differentiates from other interfaces.
	IsOrderedExprContext()
}

type OrderedExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderedExprContext() *OrderedExprContext {
	var p = new(OrderedExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_orderedExpr
	return p
}

func (*OrderedExprContext) IsOrderedExprContext() {}

func NewOrderedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderedExprContext {
	var p = new(OrderedExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_orderedExpr

	return p
}

func (s *OrderedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderedExprContext) K_ORDERED() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ORDERED, 0)
}

func (s *OrderedExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *OrderedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterOrderedExpr(s)
	}
}

func (s *OrderedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitOrderedExpr(s)
	}
}

func (p *jsoniqParser) OrderedExpr() (localctx IOrderedExprContext) {
	localctx = NewOrderedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, jsoniqParserRULE_orderedExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.Match(jsoniqParserK_ORDERED)
	}
	{
		p.SetState(742)
		p.Match(jsoniqParserT__7)
	}
	{
		p.SetState(743)
		p.Expr()
	}
	{
		p.SetState(744)
		p.Match(jsoniqParserT__8)
	}

	return localctx
}

// IUnorderedExprContext is an interface to support dynamic dispatch.
type IUnorderedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnorderedExprContext differentiates from other interfaces.
	IsUnorderedExprContext()
}

type UnorderedExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnorderedExprContext() *UnorderedExprContext {
	var p = new(UnorderedExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_unorderedExpr
	return p
}

func (*UnorderedExprContext) IsUnorderedExprContext() {}

func NewUnorderedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnorderedExprContext {
	var p = new(UnorderedExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_unorderedExpr

	return p
}

func (s *UnorderedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnorderedExprContext) K_UNORDERED() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_UNORDERED, 0)
}

func (s *UnorderedExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UnorderedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnorderedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnorderedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterUnorderedExpr(s)
	}
}

func (s *UnorderedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitUnorderedExpr(s)
	}
}

func (p *jsoniqParser) UnorderedExpr() (localctx IUnorderedExprContext) {
	localctx = NewUnorderedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, jsoniqParserRULE_unorderedExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Match(jsoniqParserK_UNORDERED)
	}
	{
		p.SetState(747)
		p.Match(jsoniqParserT__7)
	}
	{
		p.SetState(748)
		p.Expr()
	}
	{
		p.SetState(749)
		p.Match(jsoniqParserT__8)
	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) AllNCName() []antlr.TerminalNode {
	return s.GetTokens(jsoniqParserNCName)
}

func (s *FunctionCallContext) NCName(i int) antlr.TerminalNode {
	return s.GetToken(jsoniqParserNCName, i)
}

func (s *FunctionCallContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *jsoniqParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, jsoniqParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(753)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(751)
			p.Match(jsoniqParserNCName)
		}
		{
			p.SetState(752)
			p.Match(jsoniqParserT__2)
		}

	}
	{
		p.SetState(755)
		p.Match(jsoniqParserNCName)
	}
	{
		p.SetState(756)
		p.ArgumentList()
	}

	return localctx
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_argumentList
	return p
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *ArgumentListContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *jsoniqParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, jsoniqParserRULE_argumentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(758)
				p.Argument()
			}

		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())
	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) ExprSingle() IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *jsoniqParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, jsoniqParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(766)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserT__5, jsoniqParserT__7, jsoniqParserT__9, jsoniqParserT__18, jsoniqParserT__19, jsoniqParserT__22, jsoniqParserT__25, jsoniqParserT__26, jsoniqParserT__28, jsoniqParserT__29, jsoniqParserT__30, jsoniqParserK_ORDERED, jsoniqParserK_UNORDERED, jsoniqParserK_FOR, jsoniqParserK_LET, jsoniqParserK_SOME, jsoniqParserK_EVERY, jsoniqParserK_SWITCH, jsoniqParserK_TYPESWITCH, jsoniqParserK_IF, jsoniqParserK_TRY, jsoniqParserK_NOT, jsoniqParserIntegerLiteral, jsoniqParserDecimalLiteral, jsoniqParserDoubleLiteral, jsoniqParserStringLiteral, jsoniqParserNCName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(764)
			p.ExprSingle()
		}

	case jsoniqParserT__20:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(765)
			p.Match(jsoniqParserT__20)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectConstructorContext is an interface to support dynamic dispatch.
type IObjectConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectConstructorContext differentiates from other interfaces.
	IsObjectConstructorContext()
}

type ObjectConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectConstructorContext() *ObjectConstructorContext {
	var p = new(ObjectConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_objectConstructor
	return p
}

func (*ObjectConstructorContext) IsObjectConstructorContext() {}

func NewObjectConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectConstructorContext {
	var p = new(ObjectConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_objectConstructor

	return p
}

func (s *ObjectConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectConstructorContext) AllPairConstructor() []IPairConstructorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPairConstructorContext)(nil)).Elem())
	var tst = make([]IPairConstructorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPairConstructorContext)
		}
	}

	return tst
}

func (s *ObjectConstructorContext) PairConstructor(i int) IPairConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPairConstructorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPairConstructorContext)
}

func (s *ObjectConstructorContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjectConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterObjectConstructor(s)
	}
}

func (s *ObjectConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitObjectConstructor(s)
	}
}

func (p *jsoniqParser) ObjectConstructor() (localctx IObjectConstructorContext) {
	localctx = NewObjectConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, jsoniqParserRULE_objectConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(784)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserT__7:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(768)
			p.Match(jsoniqParserT__7)
		}
		p.SetState(777)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<jsoniqParserT__5)|(1<<jsoniqParserT__7)|(1<<jsoniqParserT__9)|(1<<jsoniqParserT__18)|(1<<jsoniqParserT__19)|(1<<jsoniqParserT__22)|(1<<jsoniqParserT__25)|(1<<jsoniqParserT__26)|(1<<jsoniqParserT__28)|(1<<jsoniqParserT__29)|(1<<jsoniqParserT__30))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(jsoniqParserK_ORDERED-39))|(1<<(jsoniqParserK_UNORDERED-39))|(1<<(jsoniqParserK_FOR-39))|(1<<(jsoniqParserK_LET-39)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(jsoniqParserK_SOME-78))|(1<<(jsoniqParserK_EVERY-78))|(1<<(jsoniqParserK_SWITCH-78))|(1<<(jsoniqParserK_TYPESWITCH-78))|(1<<(jsoniqParserK_IF-78))|(1<<(jsoniqParserK_TRY-78))|(1<<(jsoniqParserK_NOT-78)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(jsoniqParserIntegerLiteral-135))|(1<<(jsoniqParserDecimalLiteral-135))|(1<<(jsoniqParserDoubleLiteral-135))|(1<<(jsoniqParserStringLiteral-135))|(1<<(jsoniqParserNCName-135)))) != 0) {
			{
				p.SetState(769)
				p.PairConstructor()
			}
			p.SetState(774)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == jsoniqParserT__3 {
				{
					p.SetState(770)
					p.Match(jsoniqParserT__3)
				}
				{
					p.SetState(771)
					p.PairConstructor()
				}

				p.SetState(776)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(779)
			p.Match(jsoniqParserT__8)
		}

	case jsoniqParserT__26:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(780)
			p.Match(jsoniqParserT__26)
		}
		{
			p.SetState(781)
			p.Expr()
		}
		{
			p.SetState(782)
			p.Match(jsoniqParserT__27)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPairConstructorContext is an interface to support dynamic dispatch.
type IPairConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPairConstructorContext differentiates from other interfaces.
	IsPairConstructorContext()
}

type PairConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPairConstructorContext() *PairConstructorContext {
	var p = new(PairConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_pairConstructor
	return p
}

func (*PairConstructorContext) IsPairConstructorContext() {}

func NewPairConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PairConstructorContext {
	var p = new(PairConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_pairConstructor

	return p
}

func (s *PairConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *PairConstructorContext) AllExprSingle() []IExprSingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprSingleContext)(nil)).Elem())
	var tst = make([]IExprSingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprSingleContext)
		}
	}

	return tst
}

func (s *PairConstructorContext) ExprSingle(i int) IExprSingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprSingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprSingleContext)
}

func (s *PairConstructorContext) NCName() antlr.TerminalNode {
	return s.GetToken(jsoniqParserNCName, 0)
}

func (s *PairConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PairConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PairConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterPairConstructor(s)
	}
}

func (s *PairConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitPairConstructor(s)
	}
}

func (p *jsoniqParser) PairConstructor() (localctx IPairConstructorContext) {
	localctx = NewPairConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, jsoniqParserRULE_pairConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(786)
			p.ExprSingle()
		}

	case 2:
		{
			p.SetState(787)
			p.Match(jsoniqParserNCName)
		}

	}
	{
		p.SetState(790)
		_la = p.GetTokenStream().LA(1)

		if !(_la == jsoniqParserT__2 || _la == jsoniqParserT__20) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(791)
		p.ExprSingle()
	}

	return localctx
}

// IArrayConstructorContext is an interface to support dynamic dispatch.
type IArrayConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayConstructorContext differentiates from other interfaces.
	IsArrayConstructorContext()
}

type ArrayConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayConstructorContext() *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_arrayConstructor
	return p
}

func (*ArrayConstructorContext) IsArrayConstructorContext() {}

func NewArrayConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_arrayConstructor

	return p
}

func (s *ArrayConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayConstructorContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

func (p *jsoniqParser) ArrayConstructor() (localctx IArrayConstructorContext) {
	localctx = NewArrayConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, jsoniqParserRULE_arrayConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Match(jsoniqParserT__22)
	}
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<jsoniqParserT__5)|(1<<jsoniqParserT__7)|(1<<jsoniqParserT__9)|(1<<jsoniqParserT__18)|(1<<jsoniqParserT__19)|(1<<jsoniqParserT__22)|(1<<jsoniqParserT__25)|(1<<jsoniqParserT__26)|(1<<jsoniqParserT__28)|(1<<jsoniqParserT__29)|(1<<jsoniqParserT__30))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(jsoniqParserK_ORDERED-39))|(1<<(jsoniqParserK_UNORDERED-39))|(1<<(jsoniqParserK_FOR-39))|(1<<(jsoniqParserK_LET-39)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(jsoniqParserK_SOME-78))|(1<<(jsoniqParserK_EVERY-78))|(1<<(jsoniqParserK_SWITCH-78))|(1<<(jsoniqParserK_TYPESWITCH-78))|(1<<(jsoniqParserK_IF-78))|(1<<(jsoniqParserK_TRY-78))|(1<<(jsoniqParserK_NOT-78)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(jsoniqParserIntegerLiteral-135))|(1<<(jsoniqParserDecimalLiteral-135))|(1<<(jsoniqParserDoubleLiteral-135))|(1<<(jsoniqParserStringLiteral-135))|(1<<(jsoniqParserNCName-135)))) != 0) {
		{
			p.SetState(794)
			p.Expr()
		}

	}
	{
		p.SetState(797)
		p.Match(jsoniqParserT__23)
	}

	return localctx
}

// ISequenceTypeContext is an interface to support dynamic dispatch.
type ISequenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceTypeContext differentiates from other interfaces.
	IsSequenceTypeContext()
}

type SequenceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceTypeContext() *SequenceTypeContext {
	var p = new(SequenceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_sequenceType
	return p
}

func (*SequenceTypeContext) IsSequenceTypeContext() {}

func NewSequenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceTypeContext {
	var p = new(SequenceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_sequenceType

	return p
}

func (s *SequenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceTypeContext) ItemType() IItemTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItemTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IItemTypeContext)
}

func (s *SequenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterSequenceType(s)
	}
}

func (s *SequenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitSequenceType(s)
	}
}

func (p *jsoniqParser) SequenceType() (localctx ISequenceTypeContext) {
	localctx = NewSequenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, jsoniqParserRULE_sequenceType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(805)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserT__5:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(799)
			p.Match(jsoniqParserT__5)
		}
		{
			p.SetState(800)
			p.Match(jsoniqParserT__6)
		}

	case jsoniqParserK_ITEM, jsoniqParserK_OBJECT, jsoniqParserK_ARRAY, jsoniqParserK_JSON_ITEM, jsoniqParserK_ATOMIC, jsoniqParserK_STRING, jsoniqParserK_INTEGER, jsoniqParserK_DECIMAL, jsoniqParserK_DOUBLE, jsoniqParserK_BOOLEAN, jsoniqParserK_LONG, jsoniqParserK_SHORT, jsoniqParserK_BYTE, jsoniqParserK_FLOAT, jsoniqParserK_DATE, jsoniqParserK_DATETIME, jsoniqParserK_DATETIMESTAMP, jsoniqParserK_GDAY, jsoniqParserK_GMONTH, jsoniqParserK_GMONTHDAY, jsoniqParserK_GYEAR, jsoniqParserK_GYEARMONTH, jsoniqParserK_TIME, jsoniqParserK_DURATION, jsoniqParserK_DAYTIMEDURATION, jsoniqParserK_YEARMONTHDURATION, jsoniqParserK_BASE64NIBARY, jsoniqParserK_HEXBINARY, jsoniqParserK_ANYURI, jsoniqParserK_NULL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(801)
			p.ItemType()
		}
		p.SetState(803)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(802)
				_la = p.GetTokenStream().LA(1)

				if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<jsoniqParserT__11)|(1<<jsoniqParserT__18)|(1<<jsoniqParserT__20))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IItemTypeContext is an interface to support dynamic dispatch.
type IItemTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsItemTypeContext differentiates from other interfaces.
	IsItemTypeContext()
}

type ItemTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyItemTypeContext() *ItemTypeContext {
	var p = new(ItemTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_itemType
	return p
}

func (*ItemTypeContext) IsItemTypeContext() {}

func NewItemTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ItemTypeContext {
	var p = new(ItemTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_itemType

	return p
}

func (s *ItemTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ItemTypeContext) K_ITEM() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ITEM, 0)
}

func (s *ItemTypeContext) JsonItemTest() IJsonItemTestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJsonItemTestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJsonItemTestContext)
}

func (s *ItemTypeContext) AtomicType() IAtomicTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicTypeContext)
}

func (s *ItemTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ItemTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ItemTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterItemType(s)
	}
}

func (s *ItemTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitItemType(s)
	}
}

func (p *jsoniqParser) ItemType() (localctx IItemTypeContext) {
	localctx = NewItemTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, jsoniqParserRULE_itemType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(810)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserK_ITEM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(807)
			p.Match(jsoniqParserK_ITEM)
		}

	case jsoniqParserK_OBJECT, jsoniqParserK_ARRAY, jsoniqParserK_JSON_ITEM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(808)
			p.JsonItemTest()
		}

	case jsoniqParserK_ATOMIC, jsoniqParserK_STRING, jsoniqParserK_INTEGER, jsoniqParserK_DECIMAL, jsoniqParserK_DOUBLE, jsoniqParserK_BOOLEAN, jsoniqParserK_LONG, jsoniqParserK_SHORT, jsoniqParserK_BYTE, jsoniqParserK_FLOAT, jsoniqParserK_DATE, jsoniqParserK_DATETIME, jsoniqParserK_DATETIMESTAMP, jsoniqParserK_GDAY, jsoniqParserK_GMONTH, jsoniqParserK_GMONTHDAY, jsoniqParserK_GYEAR, jsoniqParserK_GYEARMONTH, jsoniqParserK_TIME, jsoniqParserK_DURATION, jsoniqParserK_DAYTIMEDURATION, jsoniqParserK_YEARMONTHDURATION, jsoniqParserK_BASE64NIBARY, jsoniqParserK_HEXBINARY, jsoniqParserK_ANYURI, jsoniqParserK_NULL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(809)
			p.AtomicType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJsonItemTestContext is an interface to support dynamic dispatch.
type IJsonItemTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJsonItemTestContext differentiates from other interfaces.
	IsJsonItemTestContext()
}

type JsonItemTestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonItemTestContext() *JsonItemTestContext {
	var p = new(JsonItemTestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_jsonItemTest
	return p
}

func (*JsonItemTestContext) IsJsonItemTestContext() {}

func NewJsonItemTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonItemTestContext {
	var p = new(JsonItemTestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_jsonItemTest

	return p
}

func (s *JsonItemTestContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonItemTestContext) K_OBJECT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_OBJECT, 0)
}

func (s *JsonItemTestContext) K_ARRAY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ARRAY, 0)
}

func (s *JsonItemTestContext) K_JSON_ITEM() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_JSON_ITEM, 0)
}

func (s *JsonItemTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonItemTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonItemTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterJsonItemTest(s)
	}
}

func (s *JsonItemTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitJsonItemTest(s)
	}
}

func (p *jsoniqParser) JsonItemTest() (localctx IJsonItemTestContext) {
	localctx = NewJsonItemTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, jsoniqParserRULE_jsonItemTest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(jsoniqParserK_OBJECT-106))|(1<<(jsoniqParserK_ARRAY-106))|(1<<(jsoniqParserK_JSON_ITEM-106)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAtomicTypeContext is an interface to support dynamic dispatch.
type IAtomicTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicTypeContext differentiates from other interfaces.
	IsAtomicTypeContext()
}

type AtomicTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicTypeContext() *AtomicTypeContext {
	var p = new(AtomicTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_atomicType
	return p
}

func (*AtomicTypeContext) IsAtomicTypeContext() {}

func NewAtomicTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicTypeContext {
	var p = new(AtomicTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_atomicType

	return p
}

func (s *AtomicTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicTypeContext) K_ATOMIC() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ATOMIC, 0)
}

func (s *AtomicTypeContext) K_STRING() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_STRING, 0)
}

func (s *AtomicTypeContext) K_INTEGER() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_INTEGER, 0)
}

func (s *AtomicTypeContext) K_DECIMAL() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DECIMAL, 0)
}

func (s *AtomicTypeContext) K_DOUBLE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DOUBLE, 0)
}

func (s *AtomicTypeContext) K_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_BOOLEAN, 0)
}

func (s *AtomicTypeContext) K_LONG() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_LONG, 0)
}

func (s *AtomicTypeContext) K_SHORT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_SHORT, 0)
}

func (s *AtomicTypeContext) K_BYTE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_BYTE, 0)
}

func (s *AtomicTypeContext) K_FLOAT() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_FLOAT, 0)
}

func (s *AtomicTypeContext) K_DATE() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DATE, 0)
}

func (s *AtomicTypeContext) K_DATETIME() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DATETIME, 0)
}

func (s *AtomicTypeContext) K_DATETIMESTAMP() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DATETIMESTAMP, 0)
}

func (s *AtomicTypeContext) K_GDAY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GDAY, 0)
}

func (s *AtomicTypeContext) K_GMONTH() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GMONTH, 0)
}

func (s *AtomicTypeContext) K_GMONTHDAY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GMONTHDAY, 0)
}

func (s *AtomicTypeContext) K_GYEAR() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GYEAR, 0)
}

func (s *AtomicTypeContext) K_GYEARMONTH() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_GYEARMONTH, 0)
}

func (s *AtomicTypeContext) K_TIME() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_TIME, 0)
}

func (s *AtomicTypeContext) K_DURATION() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DURATION, 0)
}

func (s *AtomicTypeContext) K_DAYTIMEDURATION() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_DAYTIMEDURATION, 0)
}

func (s *AtomicTypeContext) K_YEARMONTHDURATION() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_YEARMONTHDURATION, 0)
}

func (s *AtomicTypeContext) K_BASE64NIBARY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_BASE64NIBARY, 0)
}

func (s *AtomicTypeContext) K_HEXBINARY() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_HEXBINARY, 0)
}

func (s *AtomicTypeContext) K_ANYURI() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_ANYURI, 0)
}

func (s *AtomicTypeContext) K_NULL() antlr.TerminalNode {
	return s.GetToken(jsoniqParserK_NULL, 0)
}

func (s *AtomicTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterAtomicType(s)
	}
}

func (s *AtomicTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitAtomicType(s)
	}
}

func (p *jsoniqParser) AtomicType() (localctx IAtomicTypeContext) {
	localctx = NewAtomicTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, jsoniqParserRULE_atomicType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(jsoniqParserK_ATOMIC-109))|(1<<(jsoniqParserK_STRING-109))|(1<<(jsoniqParserK_INTEGER-109))|(1<<(jsoniqParserK_DECIMAL-109))|(1<<(jsoniqParserK_DOUBLE-109))|(1<<(jsoniqParserK_BOOLEAN-109))|(1<<(jsoniqParserK_LONG-109))|(1<<(jsoniqParserK_SHORT-109))|(1<<(jsoniqParserK_BYTE-109))|(1<<(jsoniqParserK_FLOAT-109))|(1<<(jsoniqParserK_DATE-109))|(1<<(jsoniqParserK_DATETIME-109))|(1<<(jsoniqParserK_DATETIMESTAMP-109))|(1<<(jsoniqParserK_GDAY-109))|(1<<(jsoniqParserK_GMONTH-109))|(1<<(jsoniqParserK_GMONTHDAY-109))|(1<<(jsoniqParserK_GYEAR-109))|(1<<(jsoniqParserK_GYEARMONTH-109))|(1<<(jsoniqParserK_TIME-109))|(1<<(jsoniqParserK_DURATION-109))|(1<<(jsoniqParserK_DAYTIMEDURATION-109))|(1<<(jsoniqParserK_YEARMONTHDURATION-109))|(1<<(jsoniqParserK_BASE64NIBARY-109))|(1<<(jsoniqParserK_HEXBINARY-109))|(1<<(jsoniqParserK_ANYURI-109))|(1<<(jsoniqParserK_NULL-109)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUriLiteralContext is an interface to support dynamic dispatch.
type IUriLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUriLiteralContext differentiates from other interfaces.
	IsUriLiteralContext()
}

type UriLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUriLiteralContext() *UriLiteralContext {
	var p = new(UriLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_uriLiteral
	return p
}

func (*UriLiteralContext) IsUriLiteralContext() {}

func NewUriLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UriLiteralContext {
	var p = new(UriLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_uriLiteral

	return p
}

func (s *UriLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *UriLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(jsoniqParserStringLiteral, 0)
}

func (s *UriLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UriLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UriLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterUriLiteral(s)
	}
}

func (s *UriLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitUriLiteral(s)
	}
}

func (p *jsoniqParser) UriLiteral() (localctx IUriLiteralContext) {
	localctx = NewUriLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, jsoniqParserRULE_uriLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Match(jsoniqParserStringLiteral)
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(jsoniqParserStringLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) NullLiteral() INullLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *jsoniqParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, jsoniqParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(822)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case jsoniqParserIntegerLiteral, jsoniqParserDecimalLiteral, jsoniqParserDoubleLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(818)
			p.NumericLiteral()
		}

	case jsoniqParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(819)
			p.Match(jsoniqParserStringLiteral)
		}

	case jsoniqParserT__28, jsoniqParserT__29:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(820)
			p.BooleanLiteral()
		}

	case jsoniqParserT__30:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(821)
			p.NullLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_numericLiteral
	return p
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(jsoniqParserIntegerLiteral, 0)
}

func (s *NumericLiteralContext) DecimalLiteral() antlr.TerminalNode {
	return s.GetToken(jsoniqParserDecimalLiteral, 0)
}

func (s *NumericLiteralContext) DoubleLiteral() antlr.TerminalNode {
	return s.GetToken(jsoniqParserDoubleLiteral, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (p *jsoniqParser) NumericLiteral() (localctx INumericLiteralContext) {
	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, jsoniqParserRULE_numericLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(jsoniqParserIntegerLiteral-135))|(1<<(jsoniqParserDecimalLiteral-135))|(1<<(jsoniqParserDoubleLiteral-135)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }
func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *jsoniqParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, jsoniqParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(826)
		_la = p.GetTokenStream().LA(1)

		if !(_la == jsoniqParserT__28 || _la == jsoniqParserT__29) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INullLiteralContext is an interface to support dynamic dispatch.
type INullLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullLiteralContext differentiates from other interfaces.
	IsNullLiteralContext()
}

type NullLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullLiteralContext() *NullLiteralContext {
	var p = new(NullLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = jsoniqParserRULE_nullLiteral
	return p
}

func (*NullLiteralContext) IsNullLiteralContext() {}

func NewNullLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = jsoniqParserRULE_nullLiteral

	return p
}

func (s *NullLiteralContext) GetParser() antlr.Parser { return s.parser }
func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(jsoniqListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (p *jsoniqParser) NullLiteral() (localctx INullLiteralContext) {
	localctx = NewNullLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, jsoniqParserRULE_nullLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Match(jsoniqParserT__30)
	}

	return localctx
}
