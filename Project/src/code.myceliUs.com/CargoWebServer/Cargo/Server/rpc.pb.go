// Code generated by protoc-gen-go.
// source: rpc.proto
// DO NOT EDIT!

/*
Package com_mycelius_message is a generated protocol buffer package.

It is generated from these files:
	rpc.proto

It has these top-level messages:
	Data
	Request
	Response
	Error
	Event
	Message
*/
package Server

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// *
// The tow target language are Java and JavaScript, so I will keep it close to there data type.
type Data_DataType int32

const (
	Data_DOUBLE  Data_DataType = 0
	Data_INTEGER Data_DataType = 1
	Data_STRING  Data_DataType = 2
	Data_BYTES   Data_DataType = 3
	// A JSON data structure if complex
	// data structure is needed. In that case the data will contain a JSON string.
	Data_JSON_STR Data_DataType = 4
	Data_BOOLEAN  Data_DataType = 5
)

var Data_DataType_name = map[int32]string{
	0: "DOUBLE",
	1: "INTEGER",
	2: "STRING",
	3: "BYTES",
	4: "JSON_STR",
	5: "BOOLEAN",
}
var Data_DataType_value = map[string]int32{
	"DOUBLE":   0,
	"INTEGER":  1,
	"STRING":   2,
	"BYTES":    3,
	"JSON_STR": 4,
	"BOOLEAN":  5,
}

func (x Data_DataType) Enum() *Data_DataType {
	p := new(Data_DataType)
	*p = x
	return p
}
func (x Data_DataType) String() string {
	return proto.EnumName(Data_DataType_name, int32(x))
}
func (x *Data_DataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Data_DataType_value, data, "Data_DataType")
	if err != nil {
		return err
	}
	*x = Data_DataType(value)
	return nil
}

type Message_MessageType int32

const (
	Message_REQUEST  Message_MessageType = 0
	Message_RESPONSE Message_MessageType = 1
	Message_ERROR    Message_MessageType = 2
	Message_EVENT    Message_MessageType = 3
	Message_TRANSFER Message_MessageType = 4
)

var Message_MessageType_name = map[int32]string{
	0: "REQUEST",
	1: "RESPONSE",
	2: "ERROR",
	3: "EVENT",
	4: "TRANSFER",
}
var Message_MessageType_value = map[string]int32{
	"REQUEST":  0,
	"RESPONSE": 1,
	"ERROR":    2,
	"EVENT":    3,
	"TRANSFER": 4,
}

func (x Message_MessageType) Enum() *Message_MessageType {
	p := new(Message_MessageType)
	*p = x
	return p
}
func (x Message_MessageType) String() string {
	return proto.EnumName(Message_MessageType_name, int32(x))
}
func (x *Message_MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Message_MessageType_value, data, "Message_MessageType")
	if err != nil {
		return err
	}
	*x = Message_MessageType(value)
	return nil
}

// The inspiration came from http://www.jsonrpc.org/specification
// This is not a standard implementation, but it's follow the same principle.
type Data struct {
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// *
	// Interpretation of the data depend of the data type and is managed at the application level...
	DataBytes []byte         `protobuf:"bytes,2,req,name=dataBytes" json:"dataBytes,omitempty"`
	Type      *Data_DataType `protobuf:"varint,3,req,name=type,enum=com.mycelius.message.Data_DataType,def=3" json:"type,omitempty"`
	// *
	// Use to know how to interpret the JSON struct type...
	TypeName         *string `protobuf:"bytes,4,opt,name=typeName" json:"typeName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Data) Reset()         { *m = Data{} }
func (m *Data) String() string { return proto.CompactTextString(m) }
func (*Data) ProtoMessage()    {}

const Default_Data_Type Data_DataType = Data_BYTES

func (m *Data) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Data) GetDataBytes() []byte {
	if m != nil {
		return m.DataBytes
	}
	return nil
}

func (m *Data) GetType() Data_DataType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_Data_Type
}

func (m *Data) GetTypeName() string {
	if m != nil && m.TypeName != nil {
		return *m.TypeName
	}
	return ""
}

type Request struct {
	// *
	// A String containing the name of the method to be invoked.
	Method *string `protobuf:"bytes,1,req,name=method" json:"method,omitempty"`
	// *
	// A Structured value that holds the parameter values to be used during the invocation of the method.
	// This member MAY be omitted.
	Params []*Data `protobuf:"bytes,2,rep,name=params" json:"params,omitempty"`
	// *
	// An identifier established by the Client, it's a uuid
	Id               *string `protobuf:"bytes,3,req,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}

func (m *Request) GetMethod() string {
	if m != nil && m.Method != nil {
		return *m.Method
	}
	return ""
}

func (m *Request) GetParams() []*Data {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Request) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

// *
// When a rpc call is made, the Server MUST reply with a Response, except for in the case of Notifications.
type Response struct {
	// *
	// At least on result is return for a given request, but more than one result can be return... it can be view as a tuple...
	Results []*Data `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
	// *
	// The id matching the associated request.
	Id               *string `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}

func (m *Response) GetResults() []*Data {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *Response) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

type Error struct {
	// *
	// An error code to identify the error...
	Code *int32 `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	// *
	// The description of the error...
	Message *string `protobuf:"bytes,2,req,name=message" json:"message,omitempty"`
	// *
	// The id of the request that fail.
	Id *string `protobuf:"bytes,3,req,name=id" json:"id,omitempty"`
	// *
	// Optional data dump if needed...
	Data             []byte `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}

func (m *Error) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *Error) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Error) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Event struct {
	// *
	// The event number...
	Code *int32 `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	// *
	// The event name, mostly use if error append...
	Name *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	// *
	// The data associated whit the event.
	EvtData          []*Data `protobuf:"bytes,3,rep,name=evtData" json:"evtData,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}

func (m *Event) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *Event) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Event) GetEvtData() []*Data {
	if m != nil {
		return m.EvtData
	}
	return nil
}

// *
// A container to handle all message type as the same way...
type Message struct {
	Type *Message_MessageType `protobuf:"varint,1,req,name=type,enum=com.mycelius.message.Message_MessageType,def=2" json:"type,omitempty"`
	// * If the message is bigger than the allowed size it will be split into
	//  multiple smaller message.
	Index *int32 `protobuf:"zigzag32,2,req,name=index" json:"index,omitempty"`
	Total *int32 `protobuf:"varint,3,req,name=total" json:"total,omitempty"`
	// * depending of type of these tree type will contain the message. *
	Rqst *Request  `protobuf:"bytes,4,opt,name=rqst" json:"rqst,omitempty"`
	Rsp  *Response `protobuf:"bytes,5,opt,name=rsp" json:"rsp,omitempty"`
	Err  *Error    `protobuf:"bytes,6,opt,name=err" json:"err,omitempty"`
	Evt  *Event    `protobuf:"bytes,7,opt,name=evt" json:"evt,omitempty"`
	// *
	// If the message is sent in multiple pass, this will contain the chunk...
	Data []byte `protobuf:"bytes,8,opt,name=data" json:"data,omitempty"`
	// *
	//  The message id if any...
	//  the same id of sub-message...
	Id               *string `protobuf:"bytes,9,opt,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}

const Default_Message_Type Message_MessageType = Message_ERROR

func (m *Message) GetType() Message_MessageType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_Message_Type
}

func (m *Message) GetIndex() int32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *Message) GetTotal() int32 {
	if m != nil && m.Total != nil {
		return *m.Total
	}
	return 0
}

func (m *Message) GetRqst() *Request {
	if m != nil {
		return m.Rqst
	}
	return nil
}

func (m *Message) GetRsp() *Response {
	if m != nil {
		return m.Rsp
	}
	return nil
}

func (m *Message) GetErr() *Error {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *Message) GetEvt() *Event {
	if m != nil {
		return m.Evt
	}
	return nil
}

func (m *Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Message) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func init() {
	proto.RegisterEnum("com.mycelius.message.Data_DataType", Data_DataType_name, Data_DataType_value)
	proto.RegisterEnum("com.mycelius.message.Message_MessageType", Message_MessageType_name, Message_MessageType_value)
}
