<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: handlers.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: handlers.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * (C) Copyright 2016 Mycelius SA (http://mycelius.com/).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileOverview Network messages handler.
 * @author Dave Courtois
 * @version 1.0
 */

////////////////////////////////////////////////////////////////////////////////
//                      Network stuff....
////////////////////////////////////////////////////////////////////////////////
/**
 * @constant {int} This is the maximum message size.
 */
MAX_MSG_SIZE = 17739;


// Contain the pending request waiting to be ask back...
var pendingRequest = {};

// Map of array of message chunk...
var pendingMessage = {}

////////////////////////////////////////////////////////////////////////////////
//                      The proto buffer objects...
////////////////////////////////////////////////////////////////////////////////

// This is the content of the file rpc.proto in form of string...
var protobufSrc = "package com.mycelius.message;";
protobufSrc += "message Data {required string name = 1;required bytes dataBytes = 2;"
protobufSrc += "enum DataType{ DOUBLE = 0;INTEGER = 1;STRING = 2;BYTES = 3;JSON_STR = 4;BOOLEAN = 5;}required DataType type = 3 [default = BYTES]; optional string typeName = 4;}"
protobufSrc += "message Request{required string method = 1;repeated Data params = 2;required string id = 3;}message Response{repeated Data results = 1;required string id = 2;}"
protobufSrc += "message Error{required int32 code = 1;required string message = 2;required string id = 3;optional bytes data = 4;}"
protobufSrc += "message Event{required int32 code = 1;required string name = 2;repeated Data evtData = 3;}"
protobufSrc += "message Message{enum MessageType {REQUEST = 0;RESPONSE = 1;ERROR = 2;EVENT=3;TRANSFER=4;} required MessageType type = 1 [default = ERROR];required sint32 index = 2;required int32 total = 3;optional Request rqst = 4;optional Response rsp = 5;optional Error err = 6;optional Event evt = 7; optional bytes data = 8;optional string id = 9;}"

var root = dcodeIO.ProtoBuf.protoFromString(protobufSrc).build(); //.protoFromFile("proto/rpc.proto").build();

// Use these object to create and serialyse message.
var RpcMessage = root.com.mycelius.message.Message;
var RpcRequest = root.com.mycelius.message.Request;
var RpcData = root.com.mycelius.message.Data;
var RpcResponse = root.com.mycelius.message.Response;
var RpcError = root.com.mycelius.message.Error;
var RpcEvent = root.com.mycelius.message.Event;

////////////////////////////////////////////////////////////////////////////////
//                      Web socket initialisation
////////////////////////////////////////////////////////////////////////////////
/*
 * Initialisation of the web socket handler.
 */
function initConnection(adress, onOpenCallback, onCloseCallback, onMessageCallback) {
    if ("WebSocket" in window) {
        // Let us open a web socket
        var connection = new WebSocket(adress);
        connection.onopen = function () {
            // Web Socket is connected, send data using send()
            //console.log("The web socket is open and ready to use...");
            if (onOpenCallback != undefined) {
                onOpenCallback();
            }
        };

        connection.onmessage = function (evt) {
            var arrayBuffer;
            var fileReader = new FileReader();
            var self = this;

            fileReader.onload = function () {
                arrayBuffer = this.result;
                server.handleMessage(self, arrayBuffer);
            };

            fileReader.readAsArrayBuffer(evt.data);

            if (onMessageCallback != undefined) {
                onMessageCallback();
            }
        };

        connection.onclose = function () {
            // websocket is closed.
            if (onCloseCallback != undefined) {
                onCloseCallback();
            }
        };


    }
    else {
        console.log("WebSocket NOT supported by your Browser!");
    }

    return connection;
}

/**
 * Simple data representation use to exange data between participants.
 */
var MessageData = function(name, value){
    // Hint about type name.
    this.TYPENAME = "Server.MessageData"

    /**
     * @param {string} Name The message identification.
     */
    this.Name = name

    /**
     * @param {string} Value The message content.
     */
    this.Value = value

    return this
}

////////////////////////////////////////////////////////////////////////////////
//                     Message base class
////////////////////////////////////////////////////////////////////////////////

/**
 * Wrapping RPC message.
 * @param id The message id.
 * @param conn The web socket connection reference.
 * @param progressCallback The progress callback
 * @param successCallback The success callback
 * @param errorCallback The error callback
 * @param {object} caller A place to store object from the request context and get it back from the response context.
 */
var Message = function (id, conn, progressCallback, successCallback, errorCallback, caller) {
    if (id == undefined) {
        return;
    }

    // The id is generate
    this.id = id;
    this.conn = conn; // Must have a send method... WebSocket and WebRTC has one...
    this.index = -1
    this.total = 1
    this.data = null

    // The link to the caller
    if (caller != null) {
        this.caller = caller
    }

    // Call back function...
    if (progressCallback != null) {
        this.progressCallback = progressCallback;
    }

    if (successCallback != null) {
        this.successCallback = successCallback;
    }

    if (errorCallback != null) {
        this.errorCallback = errorCallback;
    }
    return this;
};

// Must be implement by child's...
Message.prototype.getRpcMessageData = function () {
    var msg = new RpcMessage({"id": this.id, "type": 4, "index": this.index, "total": this.total, "data": utf8_to_b64(this.data)});
    return msg.toArrayBuffer();
}

function _arrayBufferToBase64(uarr) {
    var strings = [], chunksize = 0xffff;
    var len = uarr.length;

    for (var i = 0; i * chunksize &lt; len; i++){
        strings.push(String.fromCharCode.apply(null, uarr.subarray(i * chunksize, (i + 1) * chunksize)));
    }

    return strings.join("");
}

/**
 * Parse the data contain in the data/param/result map.
 * @param {bytes} The binary data sent by the server.
 */
Message.prototype.parseData = function(data){
    if( data.type == 0){
        var begin = data.dataBytes.offset;
        var end = data.dataBytes.limit;
        var val = new Float64Array(data.dataBytes.buffer.slice(begin, end))[0];
        return val
    }else if( data.type == 1){
        var begin = data.dataBytes.offset;
        var end = data.dataBytes.limit;
        var val = new Int32Array(data.dataBytes.buffer.slice(begin, end))[0];
         return val
    } else if( data.type == 2){
        var begin = data.dataBytes.offset;
        var end = data.dataBytes.limit;
        var str = new StringView(data.dataBytes.view.subarray(begin, end)).toString();
        return str;
    }else if (data.type == 3) {
        var begin = this.data.dataBytes.offset;
        var end = this.data.dataBytes.length;
        var bytes = this.data.dataBytes.view.subarray(begin, end)
        return bytes
    }else if( data.type == 4){
        var begin = data.dataBytes.offset;
        var end = data.dataBytes.limit;
        var str = new StringView(data.dataBytes.view.subarray(begin, end)).toString();
        return JSON.parse(str);
    }else if( data.type == 5){
        var begin = data.dataBytes.offset;
        var end = data.dataBytes.limit;
        var str = new StringView(data[i].dataBytes.view.subarray(begin, end)).toString();
        var val = str == "true" ? true : false
        return val
    }

    return null
}

/**
 * Send message to the server.
 */
Message.prototype.send = function () {

    // First i will create the array for the array buffer...
    var bytes = new Uint8Array(this.getRpcMessageData())

    // Here I will control the size of the message...
    if ((this.total == 1 &amp;&amp; this.index == -1) || (this.total > 1 &amp;&amp; this.index > -1)) {
        this.conn.send(bytes);
    } else if (this.total > 1) {
        // Bytes will contain the message to send to the server,
        // because it can't be send in one pass I will get it's bytes and
        // chunk it and put it inside a new message with the same id...
        var size = Math.round((bytes.byteLength / MAX_MSG_SIZE) + .5);
        for (var i = 0; i &lt; size; i++) {
            var fragment;
            if (MAX_MSG_SIZE * (i + 1) &lt; bytes.length) {
                fragment = bytes.subarray(MAX_MSG_SIZE * i, MAX_MSG_SIZE * (i + 1));
            } else {
                fragment = bytes.subarray(MAX_MSG_SIZE * i, bytes.length);
            }
            var self = this
            var msg = new Message(this.id, this.conn,
                // progress call back
                self.progressCallback,
                function (id) {
                    // Call the progression call back...
                    if (this.progressCallback != null) {
                        if (pendingMessage[id] != undefined) {
                            this.progressCallback(pendingMessage[id].length)
                        }
                    }
                    return false;
                },
                // function error call back
                self.errorCallback,
                self.caller
            );

            if (pendingMessage[this.id] == undefined) {
                // This is the message to be sent...
                pendingMessage[this.id] = new Array();
            }

            // Set the msg data...
            msg.data = Uint8ToBase64(fragment)
            msg.index = i
            msg.total = self.total
            pendingMessage[this.id][i] = msg;
        }

        // Process the next message for that id...
        processPendingMessage(this.id);
    }
};

/*
 * That function is call recursively until there no more pending message.
 */
function processPendingMessage(msgId) {
    if (pendingMessage[msgId].length > 0) {
        var msg = pendingMessage[msgId].shift();
        if (msg.progressCallback != null) {
            msg.progressCallback(msg.index, msg.total, msg.caller)
        }
        msg.send();
    } else {
        // Remove the entry
        delete pendingMessage[msgId]
    }
}

////////////////////////////////////////////////////////////////////////////////
//                     Request class
////////////////////////////////////////////////////////////////////////////////

/**
 * A class that contain value to be sent to the server.
 * @param id The message id.
 * @param conn The web socket connection reference.
 * @param method The method to be called.
 * @param params The list of parameters to pass to the methode.
 * @param progressCallback The progress callback
 * @param successCallback The success callback
 * @param errorCallback The error callback
 * @param {object} caller A place to store object from the request context and get it back from the response context.
 * @returns {*}
 * @constructor
 * @extends Message
 */
var Request = function (id, conn, method, params, progressCallback, successCallback, errorCallback, caller) {
    Message.call(this, id, conn, progressCallback, successCallback, errorCallback, caller);

    this.method = method;
    this.params = params;
    this.paramsMap = {}

    for (var i = 0; i &lt; params.length; ++i) {
        this.paramsMap[params[i].name] = params[i];
    }

    if (successCallback != null) {
        pendingRequest[this.id] = this; // Set the request on the map...
    }

    if (id != "") {
        pendingRequest[id] = this; // Insert in the pending request map...
    }

    return this;
};

// inherit from request object...
Request.prototype = new Message(null);
Request.prototype.constructor = Request;

/**
 * Create the protobuffer request object. 
 */
Request.prototype.getRpcMessageData = function () {
    var rqst = new RpcRequest({"id": this.id, "method": this.method, "params": this.params});

    // Calculate the total number of message here...
    var msg = new RpcMessage({"id": this.id, "type": 0, "rqst": rqst, "index": 1, "total": 1});

    var bytes = msg.toArrayBuffer();
    msg.total = Math.ceil(bytes.byteLength / MAX_MSG_SIZE)
    this.total = msg.total

    return bytes
}

/**
 * Read and parse data from the proto format to js format...
 */
Request.prototype.process = function () {
    for (var i = 0; i &lt; this.params.length; ++i) {
        this.paramsMap[this.params[i].name] = this.parseData(params[i])
    }

    // The ping request is a special case of request...
    if(this.method == "Ping"){
        // Send a ping response...
        var response = new Response(this.id, this.conn, [], null, null, null);
        response.send()
    }


    // Now I will create the function prototype and try to call it...
    var fn = window[this.method];
    var fnparams = []
    for (var i = 0; i &lt; this.params.length; ++i) {
        // add the param...
        fnparams.push(this.paramsMap[this.params[i].name])
    }

    // is object a function?
    if (typeof fn === "function") {
        var result = fn.apply(null, fnparams);
        //console.log("Result of request processing is " + result)
        //alert("result is : " + result)
        // Todo get the response from the funtion and create a response to send back to the server...
    }
}

/**
 * That function take the function source and function param and execute it by the client...
 * @param {string} functionSrc The js source of the function.
 * @param params The list of function parameters.
 * @constructor
 */
function ExecuteJsFunction(functionSrc, params) {
    var fn = eval("(" + functionSrc + ")")
    if (typeof fn === "function") {
        var fnparams = []
        for (var i = 0; i &lt; params.length; ++i) {
            fnparams.push(params[i].Value)
        }
        var result = fn.apply(null, fnparams)
        return result
    }
    return undefined // Nothing to be evaluated
}

////////////////////////////////////////////////////////////////////////////////
//                     Response class
////////////////////////////////////////////////////////////////////////////////
/**
 * This is the base class for a response...
 * @param {string} id The message id.
 * @param {bytes} results The result data 
 * @param {object} conn The web socket connection reference.
 * @param {function} progressCallback The progress callback
 * @param {function} successCallback The success callback
 * @param {function} errorCallback The error callback
 * @param {object} caller A place to store object from the request context and get it back from the response context.
 * @returns {*}
 * @constructor
 * @extends Message
 */
var Response = function (id, conn, results, progressCallback, successCallback, errorCallback, caller) {
    Message.call(this, id, conn, progressCallback, successCallback, errorCallback, caller);

    // I will get the results...
    this.resultsMap = {}
    this.results = results
    for (var i = 0; i &lt; results.length; ++i) {
        this.resultsMap[results[i].name] = this.parseData(results[i])
    }

    return this;
};

// inherit from request object...
Response.prototype = new Message(null);
Response.prototype.constructor = Response;

/*
 * Create the protobuffer RpcResponse from information in this class.
 */
Response.prototype.getRpcMessageData = function () {
    var resp = new RpcResponse({"id": this.id, "results": this.results});
    var msg = new RpcMessage({"id": this.id, "type": 1, "rsp": resp, "index": -1, "total": 1});
    var bytes = msg.toArrayBuffer();
    msg.total = Math.ceil(bytes.byteLength / MAX_MSG_SIZE)
    this.total = msg.total
    return bytes;
}

/*
 * Call the success callback if the response is completed.
 */
Response.prototype.execute = function () {
    var rqst = pendingRequest[this.id]
    if (rqst !== undefined) {
        if (rqst.successCallback != null) {
            if (rqst.successCallback(this.id, this.resultsMap, rqst.caller) == true) {
                delete pendingRequest[this.id]; // remove the request from the queue,,,
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//                     Event class
////////////////////////////////////////////////////////////////////////////////

// Sample use of server...
// var evt = new EventMsg(randomUUID(), server.conn, SessionEvent, LoginEvent, [], undefined, undefined, undefined)
// evt.dataMap["sessionInfo"] = result
// throw the event...
// server.sessionManager.onEvent(evt)
var EventMsg = function (id, conn, name, code, data, progressCallback, successCallback, errorCallback) {
    Message.call(this, id, conn, progressCallback, successCallback, errorCallback);

    // int value that correspond to the code...
    this.code = code

    // the event name
    this.name = name

    // This contain event specific data.
    this.dataMap = {}

    // the data byte array ready to be sent on the network.
    this.data = data

    for (var i = 0; i &lt; data.length; ++i) {
        this.dataMap[data[i].name] = this.parseData(data[i])
    }
    return this
}

// inherit from request object...
EventMsg.prototype = new Message(null);
EventMsg.prototype.constructor = EventMsg;

// Create the data to be sent over the network
EventMsg.prototype.getRpcMessageData = function () {
    var evt = new RpcEvent({"code": this.code, "name": this.name, "evtData": this.data});
    var msg = new RpcMessage({"type": 3, "evt": evt, "index": -1, "total":1});
    var bytes = msg.toArrayBuffer();
    msg.total =  Math.ceil(bytes.byteLength / MAX_MSG_SIZE)
    this.total =  msg.total

    return bytes;
}


////////////////////////////////////////////////////////////////////////////////
//                     Error class
////////////////////////////////////////////////////////////////////////////////
var ErrorMsg = function (id, conn,code, message, data, progressCallback, successCallback, errorCallback) {
    Message.call(this, id, conn, progressCallback, successCallback, errorCallback);

    // The error code
    this.code = code
    // The error message
    this.message = message
    // The error specific data...
    this.data = data

    // This contain error specific data.
    this.dataMap = {}
    if(data != null){
        for (var i = 0; i &lt; data.length; ++i) {
            this.dataMap[data[i].name] = this.parseData(data[i])
        }
    }
    return this
}

// inherit from request object...
ErrorMsg.prototype = new Message(null);
ErrorMsg.prototype.constructor = ErrorMsg;

// Create the data to be sent over the network
ErrorMsg.prototype.getRpcMessageData = function () {
    var err = new RpcError({"code": this.code, "message": this.message, "data": this.data});
    var msg = new RpcMessage({"type": 2, "err": err, "index": 1, "total":1});
    var bytes = msg.toArrayBuffer();
    msg.total =  Math.ceil(bytes.byteLength / MAX_MSG_SIZE)
    this.total =  msg.total

    return bytes;
}

ErrorMsg.prototype.catch = function () {
    var rqst = pendingRequest[this.id]
    if (rqst !== undefined) {
       if( rqst.errorCallback != null){
           // Call the error callback with this err information...
           rqst.errorCallback(this, rqst.caller)
       }
    }
    // Delete pending request in that case...
    delete pendingRequest[this.id]; // remove the request from the queue,,,
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountManager.html">AccountManager</a></li><li><a href="Attachment.html">Attachment</a></li><li><a href="CarbonCopy.html">CarbonCopy</a></li><li><a href="ColumnFilter.html">ColumnFilter</a></li><li><a href="ColumnFormater.html">ColumnFormater</a></li><li><a href="ColumnSorter.html">ColumnSorter</a></li><li><a href="DataManager.html">DataManager</a></li><li><a href="Element.html">Element</a></li><li><a href="EmailManager.html">EmailManager</a></li><li><a href="EmailManager_sendEmail.html">sendEmail</a></li><li><a href="EntityManager.html">EntityManager</a></li><li><a href="EntityPrototype.html">EntityPrototype</a></li><li><a href="EntityTableModel.html">EntityTableModel</a></li><li><a href="EventChannel.html">EventChannel</a></li><li><a href="EventChannel_BroadcastEvent.html">BroadcastEvent</a></li><li><a href="EventHandler.html">EventHandler</a></li><li><a href="EventManager.html">EventManager</a></li><li><a href="ExecuteJsFunction.html">ExecuteJsFunction</a></li><li><a href="FileManager.html">FileManager</a></li><li><a href="LanguageManager.html">LanguageManager</a></li><li><a href="Request.html">Request</a></li><li><a href="Response.html">Response</a></li><li><a href="Server.html">Server</a></li><li><a href="SessionManager.html">SessionManager</a></li><li><a href="SqlTableModel.html">SqlTableModel</a></li><li><a href="SVG_Canvas.html">SVG_Canvas</a></li><li><a href="SVG_Circle.html">SVG_Circle</a></li><li><a href="SVG_ClipPath.html">SVG_ClipPath</a></li><li><a href="SVG_Element.html">SVG_Element</a></li><li><a href="SVG_Ellipse.html">SVG_Ellipse</a></li><li><a href="SVG_ForeignObject.html">SVG_ForeignObject</a></li><li><a href="SVG_Gradient.html">SVG_Gradient</a></li><li><a href="SVG_Group.html">SVG_Group</a></li><li><a href="SVG_Image.html">SVG_Image</a></li><li><a href="SVG_Line.html">SVG_Line</a></li><li><a href="SVG_Mask.html">SVG_Mask</a></li><li><a href="SVG_Path.html">SVG_Path</a></li><li><a href="SVG_Pattern.html">SVG_Pattern</a></li><li><a href="SVG_Polygon.html">SVG_Polygon</a></li><li><a href="SVG_Polyline.html">SVG_Polyline</a></li><li><a href="SVG_Rectangle.html">SVG_Rectangle</a></li><li><a href="SVG_Text.html">SVG_Text</a></li><li><a href="SVG_Text_appendSpan.html">appendSpan</a></li><li><a href="SVG_tRef.html">SVG_tRef</a></li><li><a href="SVG_Use.html">SVG_Use</a></li><li><a href="Table.html">Table</a></li><li><a href="TableCell.html">TableCell</a></li><li><a href="TableHeader.html">TableHeader</a></li><li><a href="TableModel.html">TableModel</a></li><li><a href="TableRow.html">TableRow</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ab2str">ab2str</a></li><li><a href="global.html#addStyleString">addStyleString</a></li><li><a href="global.html#applySat">applySat</a></li><li><a href="global.html#b64_to_utf8">b64_to_utf8</a></li><li><a href="global.html#base64toBlob">base64toBlob</a></li><li><a href="global.html#contains">contains</a></li><li><a href="global.html#convertDataURIToBinary">convertDataURIToBinary</a></li><li><a href="global.html#CountSpace">CountSpace</a></li><li><a href="global.html#createElementFromHtml">createElementFromHtml</a></li><li><a href="global.html#createElementFromXml">createElementFromXml</a></li><li><a href="global.html#decode64">decode64</a></li><li><a href="global.html#encode64">encode64</a></li><li><a href="global.html#findKeyframesRule">findKeyframesRule</a></li><li><a href="global.html#framesRules">framesRules</a></li><li><a href="global.html#getContrastYIQ">getContrastYIQ</a></li><li><a href="global.html#getCurrentDateStr">getCurrentDateStr</a></li><li><a href="global.html#getNavigatorName">getNavigatorName</a></li><li><a href="global.html#getStyleRuleValue">getStyleRuleValue</a></li><li><a href="global.html#getStyleSheetByFileName">getStyleSheetByFileName</a></li><li><a href="global.html#getTextWidth">getTextWidth</a></li><li><a href="global.html#getTimeSinceStr">getTimeSinceStr</a></li><li><a href="global.html#hexToB">hexToB</a></li><li><a href="global.html#hexToG">hexToG</a></li><li><a href="global.html#hexToR">hexToR</a></li><li><a href="global.html#hexToRgb">hexToRgb</a></li><li><a href="global.html#includeJavascript">includeJavascript</a></li><li><a href="global.html#invertHex">invertHex</a></li><li><a href="global.html#isArray">isArray</a></li><li><a href="global.html#isEmail">isEmail</a></li><li><a href="global.html#isInt">isInt</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#localToGlobal">localToGlobal</a></li><li><a href="global.html#main">main</a></li><li><a href="global.html#mergeJSON">mergeJSON</a></li><li><a href="global.html#Message">Message</a></li><li><a href="global.html#MessageData">MessageData</a></li><li><a href="global.html#Name">Name</a></li><li><a href="global.html#propertyFromStylesheet">propertyFromStylesheet</a></li><li><a href="global.html#randomArray">randomArray</a></li><li><a href="global.html#randomColor">randomColor</a></li><li><a href="global.html#randomIntFromInterval">randomIntFromInterval</a></li><li><a href="global.html#randomUUID">randomUUID</a></li><li><a href="global.html#resizeImage">resizeImage</a></li><li><a href="global.html#Restriction">Restriction</a></li><li><a href="global.html#rgbToHsl">rgbToHsl</a></li><li><a href="global.html#selectText">selectText</a></li><li><a href="global.html#server">server</a></li><li><a href="global.html#setObjectValues">setObjectValues</a></li><li><a href="global.html#shuffleArray">shuffleArray</a></li><li><a href="global.html#StartWith">StartWith</a></li><li><a href="global.html#str2ab">str2ab</a></li><li><a href="global.html#This">This</a></li><li><a href="global.html#Uint8ToBase64">Uint8ToBase64</a></li><li><a href="global.html#utf8_to_b64">utf8_to_b64</a></li><li><a href="global.html#value">value</a></li><li><a href="global.html#Value">Value</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Jul 27 2016 17:16:32 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
