<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: server.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: server.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * (C) Copyright 2016 Mycelius SA (http://mycelius.com/).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileOverview The definiton of Server class.
 * @author Dave Courtois
 * @version 1.0
 */

/**
 * The sever class is a representation of a distant server into a local object.
 * It regroup other manager object to give access to different services like file management, data manager etc...
 * @param {string} hostName The domain name of the server.
 * @param {string} ipv4 The ip v4 adress of the server.
 * @param {int} port The port number of the sever.
 * @constructor
 */
var Server = function(hostName, ipv4, port){

    /**
     * @property {string} hostName The server side domain name.
     * @example www.cargoWebserver.com
     * @example localhost
     */
    this.hostName = hostName

    /**
     * @property {string} ipv4 the ip adress of the server.
     * @example 127.0.0.1
     */
    this.ipv4 = ipv4

    /**
     * @property {int} port the port number.
     * @example 8080
     */
    this.port = port

    /**
     * @property {string} sessionId Identify the client with the server.
     */
    this.sessionId = null

    /**
     * @property {object} conn The web socket connection between the client and the server. 
     */
    this.conn = null

    /**
     * @property {LanguageManager} languageManager Manage the language in GUI. 
     */
    this.languageManager = new LanguageManager()
    this.languageManager.appendLanguageInfo(languageInfo)

    /**
     * @property {EventHandler} eventHandler Manage the network event. 
     */
    this.eventHandler = new EventHandler()

    /**
     * @property {AccountManager} accountManager Accounts related functions. 
     */
    this.accountManager = null

    /**
     * @property {SessionManager} sessionManager Users sessions related functions. 
     */
    this.sessionManager = null
    
    this.errorManager = null
    this.workflowManager = null
    this.fileManager = null
    this.entityManager = null
    this.dataManager = null
    this.emailManager = null

    return this;
}

/**
 * That function is use to execute javascript function on the server side and get the result back
 * if there any.
 * @param {string} sessionId  The active session id.
 * @param {string} functionSrc  The source code of the function itself.
 * @param {array} functionParams  The list of function parameters.
 * @param {callback} progressCallback The function called when information is transfer from the server to client.
 * @param {callback} successCallback The success function to execute if the function success
 * @param {callback} errorCallback Call in case of error...
 * @param {object} caller This is the caller object of the function, it can be use full if other action are to be call on it.
 */
Server.prototype.executeJsFunction = function(functionSrc, functionParams, progressCallback, successCallback, errorCallback, caller){
    var params = []
    params.push(new RpcData({"name": "functionSrc", "type": 2, "dataBytes":  utf8_to_b64(functionSrc)}))

    for(var i=0; i &lt; functionParams.length; i++){
        params.push(functionParams[i])
    }

    var rqst = new Request(randomUUID(), server.conn, "ExecuteJsFunction", params,
        // Progress call back
        function (index, total, caller) {
            progressCallback(index, total, caller)
        },
        // success call back
        function (id, results, caller) {
            // So here I will format the results...
            var result = results["result"]
            // Call the successCallback whit the information.
            successCallback(result, caller)
            return true;
        },
        // Error call back
        function (errMsg, caller) {
            errorCallback(errMsg, caller)
        },
        caller
    );
    rqst.send()
}

/*
 * Handle the messages received.
 */
Server.prototype.handleMessage = function (conn, data) {
    
    // I will decode the message...
    var msg = RpcMessage.decode(data);

    // Here the sever ask for something...
    if (msg.type === 0) {
        // Request
        //console.log("request receive...");
        // I will create the Rpc request object...
        var request = new Request(msg.rqst.id, conn, msg.rqst.method, msg.rqst.params, null, null, null);
        request.process()
    }
    // Here I receive an answer from the server.
    else if (msg.type === 1) {
        // Response
        //console.log("Response received...");
        var response = new Response(msg.rsp.id, conn, msg.rsp.results, null, null, null);
        if (pendingMessage[response.id] != undefined) {
            processPendingMessage(response.id)
        } else {
            response.execute();
        }

    }
    // I receive an error from the server...
    else if (msg.type === 2) {
        // error
        //console.log("Error received...");
        // Here I will create the error message...
        var err = new ErrorMsg(msg.err.id, conn, msg.err.code, msg.err.message, msg.err.data, null, null, null)
        err.catch()

    }
    // I receive event from the server.
    else if (msg.type === 3) {
        // event
        //console.log("Event received...");
        var evt = new EventMsg(msg.evt.id, conn, msg.evt.name, msg.evt.code, msg.evt.evtData, null, null, null)
        server.eventHandler.BroadcastEvent(evt)
    }
    // This is a transfer message use whit chunk message...
    else if (msg.type === 4) {

        // Here I need to save the message into the pending message map...
        if (pendingMessage[msg.id] == undefined) {
            // I will create the array first...
            pendingMessage[msg.id] = new Array()
        }

        // Now I will save the message...
        pendingMessage[msg.id][msg.index] = msg

        if(pendingRequest[msg.id].progressCallback != null){
            pendingRequest[msg.id].progressCallback(msg.index, msg.total, pendingRequest[msg.id].caller)
        }

        // I will now create the answer for that transfer message and send it back
        // to the server...
        var results = new Array()
        var resp = new Response(msg.id, conn, results, null, null, null)
        resp.send()

        // If the message is fully transfer...
        if (msg.index == msg.total - 1) {
            // Here is the case of fragmented response... so I need to reconstruct the response from
            // the data contain in the assembled message...
            var data = []
            for (var i = 0; i &lt; pendingMessage[msg.id].length; i++) {
                var begin = pendingMessage[msg.id][i].data.offset;
                var end = pendingMessage[msg.id][i].data.limit;
                data[i] = pendingMessage[msg.id][i].data.view.subarray(begin, end)
            }

            // Now I will delete the message...
            delete pendingMessage[msg.id]


            var fileReader = new FileReader();
            fileReader.onload = function () {
                if(this.result != null){
                    var arrayBuffer = this.result;
                    server.handleMessage(server.conn, arrayBuffer);
                }else{
                    console.log("File data cannot be read!!!")
                }
            };

            fileReader.readAsArrayBuffer(new Blob(data));
        }
    }
};

/**
 * Get the current session id...
 */
Server.prototype.setSessionId = function(){
    var params = new Array();
    // Register this listener to the server.
    var rqst = new Request(randomUUID(), server.conn, "GetSessionId", params,
        // Progress callback
        function(){},
        // Success callback
        function(id, results, server){
            // Keep the session id...
            server.sessionId = results.result

            // Each application must contain a main...
            if (main != null) {
                // Go to the main entry point
                // Here I will append the listener for the entity...
                // The session listener...
                server.entityManager.getEntityPrototypes("BPMN20", function(result, caller){
                    //console.log(result)
                    server.entityManager.getEntityPrototypes("BPMS_Runtime", function(result, caller){
                        //console.log(result)
                        server.entityManager.getEntityPrototypes("CargoEntities", function(result, caller){
                            //console.log(result)
                            server.entityManager.getEntityPrototypes("CargoConfig", function(result, caller){
                                //console.log(result)
                                main()
                            }, function(){/* Error callback */}, null)
                        }, function(){/* Error callback */}, null)
                    }, function(){/* Error callback */}, null)
                }, function(){/* Error callback */}, null)

            } else {
                // I will show the project manager page...
                // TODOO error 404
                //alert("Error 404, Cargo handler.js line 121")
            }
        },
        // Error callback...
        function(){

        }, this);
    rqst.send();
}


/*
 * Sever side code.
 */
function SetRootPath(path) {
    // Call set root path on the server...
    server.SetRootPath(path)
}

/**
 * Set the application root path.
 * @param {string} path The application root path on the server.
 * @param {function} successCallback The function is call in case of success and the result parameter contain objects we looking for.
 * @param {function} errorCallback In case of error.
 * @param {object} caller A place to store object from the request context and get it back from the response context.
 */
Server.prototype.setRootPath = function (path, successCallback, errorCallback, caller) {

    // server is the client side singleton...
    var params = []
    params.push(new RpcData({ "name": "rootPath", "type": 2, "dataBytes": utf8_to_b64(path) }))

    // Call it on the server.
    server.executeJsFunction(
        RemoveEntity.toString(), // The function to execute remotely on server
        params, // The parameters to pass to that function
        function (index, total, caller) { // The progress callback
            // Nothing special to do here.
        },
        function (result, caller) {
            //console.log(result)
            caller.successCallback(result[0], caller.caller)
        },
        function (errMsg, caller) {
            console.log(errMsg)
            server.errorManager.onError(errMsg)
            caller.errorCallback(errMsg, caller.caller)
        }, // Error callback
        { "caller": caller, "successCallback": successCallback, "errorCallback": errorCallback } // The caller
    )
}

function Connect(host, port) {
    server.Connect(host, port)
}

/**
 * Create a connection to another server from the current server.
 * @param {string} host The host name of the server to connect with.
 * @param {int} port The port number of the distant host.
 * @param {function} successCallback The function is call in case of success and the result parameter contain objects we looking for.
 * @param {function} errorCallback In case of error.
 * @param {object} caller A place to store object from the request context and get it back from the response context.
 */
Server.prototype.connect = function (host, port, successCallback, errorCallback, caller) {

    // server is the client side singleton...
    var params = []
    params.push(new RpcData({ "name": "host", "type": 2, "dataBytes": utf8_to_b64(path) }))
    params.push(new RpcData({ "name": "port", "type": 1, "dataBytes": utf8_to_b64(path) }))

    // Call it on the server.
    server.executeJsFunction(
        RemoveEntity.toString(), // The function to execute remotely on server
        params, // The parameters to pass to that function
        function (index, total, caller) { // The progress callback
            // Nothing special to do here.
        },
        function (result, caller) {
            //console.log(result)
            caller.successCallback(result[0], caller.caller)
        },
        function (errMsg, caller) {
            console.log(errMsg)
            server.errorManager.onError(errMsg)
            caller.errorCallback(errMsg, caller.caller)
        }, // Error callback
        { "caller": caller, "successCallback": successCallback, "errorCallback": errorCallback } // The caller
    )
}

function Disconnect(host, port) {
    server.Disconnect(host, port)
}

/**
 * Close the connection to another server from the current server.
 * @param {string} host The host name of the server to connect with.
 * @param {int} port The port number of the distant host.
 * @param {function} successCallback The function is call in case of success and the result parameter contain objects we looking for.
 * @param {function} errorCallback In case of error.
 * @param {object} caller A place to store object from the request context and get it back from the response context.
 */
Server.prototype.disconnect = function (host, port, successCallback, errorCallback, caller) {

    // server is the client side singleton...
    var params = []
    params.push(new RpcData({ "name": "host", "type": 2, "dataBytes": utf8_to_b64(path) }))
    params.push(new RpcData({ "name": "port", "type": 1, "dataBytes": utf8_to_b64(path) }))

    // Call it on the server.
    server.executeJsFunction(
        RemoveEntity.toString(), // The function to execute remotely on server
        params, // The parameters to pass to that function
        function (index, total, caller) { // The progress callback
            // Nothing special to do here.
        },
        function (result, caller) {
            //console.log(result)
            caller.successCallback(result[0], caller.caller)
        },
        function (errMsg, caller) {
            console.log(errMsg)
            server.errorManager.onError(errMsg)
            caller.errorCallback(errMsg, caller.caller)
        }, // Error callback
        { "caller": caller, "successCallback": successCallback, "errorCallback": errorCallback } // The caller
    )
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountManager.html">AccountManager</a></li><li><a href="Attachment.html">Attachment</a></li><li><a href="CarbonCopy.html">CarbonCopy</a></li><li><a href="ColumnFilter.html">ColumnFilter</a></li><li><a href="ColumnFormater.html">ColumnFormater</a></li><li><a href="ColumnSorter.html">ColumnSorter</a></li><li><a href="DataManager.html">DataManager</a></li><li><a href="Element.html">Element</a></li><li><a href="EmailManager.html">EmailManager</a></li><li><a href="EmailManager_sendEmail.html">sendEmail</a></li><li><a href="EntityManager.html">EntityManager</a></li><li><a href="EntityPrototype.html">EntityPrototype</a></li><li><a href="EntityTableModel.html">EntityTableModel</a></li><li><a href="EventChannel.html">EventChannel</a></li><li><a href="EventChannel_BroadcastEvent.html">BroadcastEvent</a></li><li><a href="EventHandler.html">EventHandler</a></li><li><a href="EventManager.html">EventManager</a></li><li><a href="ExecuteJsFunction.html">ExecuteJsFunction</a></li><li><a href="FileManager.html">FileManager</a></li><li><a href="LanguageManager.html">LanguageManager</a></li><li><a href="Request.html">Request</a></li><li><a href="Response.html">Response</a></li><li><a href="Server.html">Server</a></li><li><a href="SessionManager.html">SessionManager</a></li><li><a href="SqlTableModel.html">SqlTableModel</a></li><li><a href="SVG_Canvas.html">SVG_Canvas</a></li><li><a href="SVG_Circle.html">SVG_Circle</a></li><li><a href="SVG_ClipPath.html">SVG_ClipPath</a></li><li><a href="SVG_Element.html">SVG_Element</a></li><li><a href="SVG_Ellipse.html">SVG_Ellipse</a></li><li><a href="SVG_ForeignObject.html">SVG_ForeignObject</a></li><li><a href="SVG_Gradient.html">SVG_Gradient</a></li><li><a href="SVG_Group.html">SVG_Group</a></li><li><a href="SVG_Image.html">SVG_Image</a></li><li><a href="SVG_Line.html">SVG_Line</a></li><li><a href="SVG_Mask.html">SVG_Mask</a></li><li><a href="SVG_Path.html">SVG_Path</a></li><li><a href="SVG_Pattern.html">SVG_Pattern</a></li><li><a href="SVG_Polygon.html">SVG_Polygon</a></li><li><a href="SVG_Polyline.html">SVG_Polyline</a></li><li><a href="SVG_Rectangle.html">SVG_Rectangle</a></li><li><a href="SVG_Text.html">SVG_Text</a></li><li><a href="SVG_Text_appendSpan.html">appendSpan</a></li><li><a href="SVG_tRef.html">SVG_tRef</a></li><li><a href="SVG_Use.html">SVG_Use</a></li><li><a href="Table.html">Table</a></li><li><a href="TableCell.html">TableCell</a></li><li><a href="TableHeader.html">TableHeader</a></li><li><a href="TableModel.html">TableModel</a></li><li><a href="TableRow.html">TableRow</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ab2str">ab2str</a></li><li><a href="global.html#addStyleString">addStyleString</a></li><li><a href="global.html#applySat">applySat</a></li><li><a href="global.html#b64_to_utf8">b64_to_utf8</a></li><li><a href="global.html#base64toBlob">base64toBlob</a></li><li><a href="global.html#contains">contains</a></li><li><a href="global.html#convertDataURIToBinary">convertDataURIToBinary</a></li><li><a href="global.html#CountSpace">CountSpace</a></li><li><a href="global.html#createElementFromHtml">createElementFromHtml</a></li><li><a href="global.html#createElementFromXml">createElementFromXml</a></li><li><a href="global.html#decode64">decode64</a></li><li><a href="global.html#encode64">encode64</a></li><li><a href="global.html#findKeyframesRule">findKeyframesRule</a></li><li><a href="global.html#framesRules">framesRules</a></li><li><a href="global.html#getContrastYIQ">getContrastYIQ</a></li><li><a href="global.html#getCurrentDateStr">getCurrentDateStr</a></li><li><a href="global.html#getNavigatorName">getNavigatorName</a></li><li><a href="global.html#getStyleRuleValue">getStyleRuleValue</a></li><li><a href="global.html#getStyleSheetByFileName">getStyleSheetByFileName</a></li><li><a href="global.html#getTextWidth">getTextWidth</a></li><li><a href="global.html#getTimeSinceStr">getTimeSinceStr</a></li><li><a href="global.html#hexToB">hexToB</a></li><li><a href="global.html#hexToG">hexToG</a></li><li><a href="global.html#hexToR">hexToR</a></li><li><a href="global.html#hexToRgb">hexToRgb</a></li><li><a href="global.html#includeJavascript">includeJavascript</a></li><li><a href="global.html#invertHex">invertHex</a></li><li><a href="global.html#isArray">isArray</a></li><li><a href="global.html#isEmail">isEmail</a></li><li><a href="global.html#isInt">isInt</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#localToGlobal">localToGlobal</a></li><li><a href="global.html#main">main</a></li><li><a href="global.html#mergeJSON">mergeJSON</a></li><li><a href="global.html#Message">Message</a></li><li><a href="global.html#MessageData">MessageData</a></li><li><a href="global.html#Name">Name</a></li><li><a href="global.html#propertyFromStylesheet">propertyFromStylesheet</a></li><li><a href="global.html#randomArray">randomArray</a></li><li><a href="global.html#randomColor">randomColor</a></li><li><a href="global.html#randomIntFromInterval">randomIntFromInterval</a></li><li><a href="global.html#randomUUID">randomUUID</a></li><li><a href="global.html#resizeImage">resizeImage</a></li><li><a href="global.html#Restriction">Restriction</a></li><li><a href="global.html#rgbToHsl">rgbToHsl</a></li><li><a href="global.html#selectText">selectText</a></li><li><a href="global.html#server">server</a></li><li><a href="global.html#setObjectValues">setObjectValues</a></li><li><a href="global.html#shuffleArray">shuffleArray</a></li><li><a href="global.html#StartWith">StartWith</a></li><li><a href="global.html#str2ab">str2ab</a></li><li><a href="global.html#This">This</a></li><li><a href="global.html#Uint8ToBase64">Uint8ToBase64</a></li><li><a href="global.html#utf8_to_b64">utf8_to_b64</a></li><li><a href="global.html#value">value</a></li><li><a href="global.html#Value">Value</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Jul 27 2016 17:16:32 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
